<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见服务器限流算法及实现</title>
    <link href="/MyBlog/2023/05/06/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/MyBlog/2023/05/06/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器限流服务"><a href="#服务器限流服务" class="headerlink" title="服务器限流服务"></a>服务器限流服务</h1><p>限流服务是服务端常用的保证进程稳定性的手段，常见的限流算法有：<strong>计数器、固定窗口，滑动窗口、漏桶、令牌桶</strong></p><h2 id="1-计数器算法"><a href="#1-计数器算法" class="headerlink" title="1.计数器算法"></a><strong>1.计数器算法</strong></h2><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。</p><p>那么我们可以每一分钟重置下计数器counter，当请求到来时，如果距离上次重置计数器在一分钟以内就将counter加1，如果1分钟内counter的值大于100则说明请求过多，需要限流，具体算法的示意图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-bd04d1f09aca34d8805b7a256674ba21_720w.webp"></p><p>这个算法虽然简单，但是<strong>存在临界问题</strong>，我们看下图：</p><p><img src="https://pic1.zhimg.com/80/v2-21d2f4d147c28dcba3e7a448a7fd6924_720w.webp"></p><p>假设一个用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。也就是该玩家在1秒内请求量达到了限流上限的2倍，会对服务器造成瞬时压力。</p><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a><strong>2. 滑动窗口</strong></h2><p>滑动窗口，又称rolling window。可解决计数算法的临界问题。类似于TCP中的滑动窗口算法，我们在计算counter的时候并不是计算0:00~1:00这样固定的时间窗口的请求总数，而是计算距离当前最近1分钟的请求总量，这样就可避免请求量短时间内突破限流上限。</p><p><img src="https://pic2.zhimg.com/80/v2-a2a403b505a5d387a95eeed76a5515c1_720w.webp"></p><p>如上图中，我们将1分钟按照每10s划分为6个格子，每个格子有自己单独的计数器组成一个count_lst。当新请求到来时，首先根据上次请求时间与当前时间差对窗口进行移动，新请求其所属时间格子一定是最后一个10s内，因此可以直接count_lst[-1]+&#x3D;1。在滑动窗口中我们统计最近1分钟的计数器之和来进行限流。</p><h2 id="3-令牌桶算法"><a href="#3-令牌桶算法" class="headerlink" title="3.令牌桶算法"></a><strong>3.令牌桶算法</strong></h2><p>滑动窗口虽然解决了瞬时请求过大问题，但是并不要求请求在时间窗口中均匀分布，令牌桶算法则可以限制请求速率。我们将请求发行的凭证称之为令牌，请求只有获取到合法令牌才能避免被限流，而令牌桶算法会限制最大令牌数量即桶的容量，并且当令牌桶没有满的时候会定时产生一定数量的令牌加入到桶中。每个请求会消耗一些令牌，如果令牌容量小于单次请求消耗的令牌数量，则请求被限制。</p><p><img src="https://pic3.zhimg.com/80/v2-fcd054bc771bf1856d6428837815582e_720w.webp"></p><p>缺点：令牌桶，假如系统上线时没有预热，那么可能会出现由于此时桶中还没有令牌，而导致请求被误杀的情况</p><h2 id="4-漏桶算法"><a href="#4-漏桶算法" class="headerlink" title="4.漏桶算法"></a><strong>4.漏桶算法</strong></h2><p>令牌桶算法缓存请求通行的凭证，而漏桶算法则是缓存请求；漏桶算法的基本思想是，流量持续进入漏桶中，底部则<strong>定速处理</strong>请求，如果流量进入的速率高于底部请求被处理的速率，且当桶中的流量超过桶的大小时，流量就会被溢出。具体如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-c1186190a3ab7bcb6c24ac6a5cd13fc7_720w.webp"></p><p>漏桶中由于请求是暂存在桶中的，所以请求什么时候能被处理，则是有延时的。</p><h2 id="5-限流服务实现"><a href="#5-限流服务实现" class="headerlink" title="5.限流服务实现"></a>5.限流服务实现</h2><p>由于使用场景和服务器架构的不同，应该选用不同的限流算法。相比单一机器或者进程的限流服务，分布式服务器架构中的限流服务相对复杂一些。本质上单机限流和分布式限流的区别其实在于 “计数器” 存放的位置。</p><p>针对单机限流，我们可以直接将计数器存放到内存中，以下是python实现的滑动窗口单机限流源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SlidingWindow</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">        滑动窗口限流本进程使用</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, window_size, window_ts, threshold</span>):<br>        self.window_size = window_size          <span class="hljs-comment"># 窗口大小</span><br>        self.window_unit_ts = window_ts         <span class="hljs-comment"># 窗口时间单元 单位：秒</span><br>        self.threshold = threshold              <span class="hljs-comment"># 最大请求次数</span><br>        self.count_lst = []                     <span class="hljs-comment"># 记录单元次数</span><br>        self.last_refresh_time = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_count_lst</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">            初始化滑动窗口</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.count_lst = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> xrange(self.window_size)]<br>        now = time.time()<br>        self.last_refresh_time = now - now % self.window_unit_ts<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">refresh_count_lst</span>(<span class="hljs-params">self, now</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            更新滑动窗口</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        expire_unit = <span class="hljs-built_in">int</span>((now - self.last_refresh_time) / self.window_unit_ts)<br>        expire_unit = <span class="hljs-built_in">min</span>(expire_unit, self.window_size)<br>        self.count_lst = self.count_lst[expire_unit:]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(self.window_size - <span class="hljs-built_in">len</span>(self.count_lst)):<br>            self.count_lst.append(<span class="hljs-number">0</span>)<br>        self.last_refresh_time = now - now % self.window_unit_ts<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">try_request</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            尝试请求</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        now = time.time()<br>        self.refresh_count_lst(now)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(self.count_lst) &gt;= self.threshold:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        self.count_lst[-<span class="hljs-number">1</span>] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>上述代码中定义了窗口大小，每个窗口单元的时间长度，请求阈值，基于这三个值就可以实现单机限流服务了。另外窗口计数器需要随时间更新，可定时对count_lt进行更新，也可在每次请求到来时先检查窗口状态，这里采用请求时更新。</p><p>分布式限流可基redis做中心节点，例如滑动窗口的每个请求的时间记录可以利用 redis 的 <code>zset</code> 存储，利用<code>ZREMRANGEBYSCORE</code> 删除时间窗口之外的数据，再用 <code>ZCARD</code>计数。<strong>需要注意的是操作redis的原子性</strong>，采用lua脚本操作redis可解决原子操作的问题，如下是lua+redis实现的令牌桶算法。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> max_permits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">local</span> permits_per_second = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">local</span> required_permits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])<br><span class="hljs-keyword">local</span> last_free_ticket_micros = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;hget&#x27;</span>, key, <span class="hljs-string">&#x27;last_free_ticket_micros&#x27;</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">time</span> = redis.call(<span class="hljs-string">&#x27;time&#x27;</span>)<br><span class="hljs-keyword">local</span> now_micros = <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">time</span>[<span class="hljs-number">1</span>]) * <span class="hljs-number">1000000</span> + <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">time</span>[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">local</span> stored_permits = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;hget&#x27;</span>, key, <span class="hljs-string">&#x27;stored_permits&#x27;</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<br><span class="hljs-keyword">local</span> stable_interval_micros = <span class="hljs-number">1000000</span> / permits_per_second<br><span class="hljs-keyword">if</span> (now_micros &gt; last_free_ticket_micros) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">local</span> new_permits = (now_micros - last_free_ticket_micros) / stable_interval_micros<br>    stored_permits = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(max_permits, stored_permits + new_permits)<br>    last_free_ticket_micros = now_micros<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> res = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> (stored_permits &gt;= required_permits) <span class="hljs-keyword">then</span><br>    stored_permits = stored_permits - required_permits<br>    res = <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br>redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, <span class="hljs-string">&#x27;stored_permits&#x27;</span>, stored_permits)<br>redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, <span class="hljs-string">&#x27;last_free_ticket_micros&#x27;</span>, last_free_ticket_micros)<br><span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>python层可通过封装redis的EVAL或者EVALSHA命令来运行lua脚本</p><h2 id="限流的难点"><a href="#限流的难点" class="headerlink" title="限流的难点"></a><strong>限流的难点</strong></h2><p>可以看到每个限流都有个阈值，这个阈值如何定是个难点。定大了服务器可能顶不住，定小了就“误杀”了，没有资源利用最大化，对用户体验不好。</p><p>最好的办法是能动态地调整限流的阈值，于是可以基于TCP拥塞控制的思想，根据请求响应在一个时间段的响应时间来确定此时服务器的健康状况，从而动态调整限流阈值。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python和C++混合编程</title>
    <link href="/MyBlog/2022/12/15/python%E5%92%8CC-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
    <url>/MyBlog/2022/12/15/python%E5%92%8CC-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="python和C-混合编程"><a href="#python和C-混合编程" class="headerlink" title="python和C++混合编程"></a>python和C++混合编程</h1><p>我们知道python是c语言编写的，python可调用c方法同时，c也可调用python模块</p><p>Python和C++混合编程主要分为两方面：</p><ul><li><strong>在Python中使用C++编写的库；</strong></li><li><strong>在C++中使用Python语义（嵌入Python，操作Python标准库和第三方库）；</strong></li></ul><p>Python与C++是通过一个虚拟机来进行交互的，因此要实现C++与Python的互相调用，必须先启动一个虚拟机。启动并使用一个Python虚拟机只需要简单的几步：</p><ol><li>包含python.h头文件</li><li>调用Py_Initialize()启动虚拟机（初始化）</li><li>C++与Python互相调用</li><li>使⽤Py_Finalize()关闭虚拟机（撤销初始化的所有操作）</li></ol><h2 id="1-C-调用Python"><a href="#1-C-调用Python" class="headerlink" title="1.C++调用Python"></a>1.C++调用Python</h2><p>在C++中调用Python中的对象，关键是要在C++中能引用Python对象。我们先回顾一下Python中是怎么做的，假设在Game目录下有MyGame.py、Hero.py两个文件（模块）</p><p>这些通过Python语言编写的逻辑最终都发生在Python虚拟机中，如果说通过C++语言也能在Python虚拟机中实现上述逻辑，是不是就可以实现C++对Python对象的调用？是的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一步：导入Hero模块</span><br>PyObject* HeroMoudle = <span class="hljs-built_in">PyImport_ImportModule</span>(<span class="hljs-string">&quot;Game.Hero&quot;</span>);<br><br><span class="hljs-comment">//第二步：在Hero的dict中获取FUNCClass类</span><br>PyObject* HeroMoudleDict = <span class="hljs-built_in">PyModule_GetDict</span>(HeroMoudle);<br>PyObject* FUNCClass = <span class="hljs-built_in">PyDict_GetItemString</span>(HeroMoudleDict, <span class="hljs-string">&quot;FUNCClass&quot;</span>);<br><br><span class="hljs-comment">//第三步：实例化FUNCClass类</span><br>PyObject* HeroFUNCClass = <span class="hljs-built_in">PyObject_CallObject</span>(FUNCClass, <span class="hljs-literal">NULL</span>);<br>PyObject* ret = <span class="hljs-built_in">PyObject_CallMethod</span>(HeroFUNCClass, <span class="hljs-string">&quot;say&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;Don&#x27;t run, monster&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-Python调用C"><a href="#2-Python调用C" class="headerlink" title="2.Python调用C++"></a>2.Python调用C++</h2><p>python调用C++有两种方法：</p><ol><li><p>使用python扩展</p></li><li><p>使用ctypes直接加载so</p></li></ol><p>  Python的可扩展性具有的优点：方便为语言增加新功能、具有可定制性、代码可以实现复用等。这种方法要引入Python中的一个重要的类PyObject和一个重要的接口函数PyArg_ParseTuple: 例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Python.h&gt;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fab</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123; <br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>) <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>  <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">fab</span>(n - <span class="hljs-number">1</span>); <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">register</span> <span class="hljs-type">char</span> t,  <br>            *p = s,  <br>            *q = (s + (<span class="hljs-built_in">strlen</span>(s) - <span class="hljs-number">1</span>));  <br><br>    <span class="hljs-keyword">while</span> (s &amp;&amp; (p &lt; q))  <br>    &#123;  <br>        t = *p;  <br>        *p++ = *q;  <br>        *q-- = t;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span>(s);  <br>&#125; <br><br><span class="hljs-function">PyObject* <span class="hljs-title">wrap_fab</span><span class="hljs-params">(PyObject* self, PyObject* args)</span> </span><br><span class="hljs-function"></span>&#123; <br>  <span class="hljs-type">int</span> n, result; <br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PyArg_ParseTuple</span>(args, <span class="hljs-string">&quot;i:fab&quot;</span>, &amp;n)) <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>  result = <span class="hljs-built_in">fab</span>(n); <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Py_BuildValue</span>(<span class="hljs-string">&quot;i&quot;</span>, result); <br>&#125; <br><br><span class="hljs-function">PyObject* <span class="hljs-title">wrap_reverse</span><span class="hljs-params">(PyObject* self, PyObject* args)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">char</span>* orig_str;<br>   <span class="hljs-type">char</span>* dupe_str;<br>   PyObject* retVal;<br><br>   <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">PyArg_ParseTuple</span>(args,<span class="hljs-string">&quot;s:reverse&quot;</span>,&amp;orig_str))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>   dupe_str = <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">strdup</span>(orig_str));<br>   retVal = (PyObject*)<span class="hljs-built_in">Py_BuildValue</span>(<span class="hljs-string">&quot;ss&quot;</span>,orig_str,dupe_str);<br>   <span class="hljs-built_in">free</span>(dupe_str);<br><span class="hljs-keyword">return</span> retVal;<br>&#125;<br><br><span class="hljs-type">static</span> PyMethodDef exampleMethods[] = <br>&#123; <br><span class="hljs-comment">//&#123;python中使用的函数名，C++中的函数指针, 函数标记，函数注释&#125;</span><br>  &#123;<span class="hljs-string">&quot;fab&quot;</span>, wrap_fab, METH_VARARGS, <span class="hljs-string">&quot;Caculate N!&quot;</span>&#125;, <br>  &#123;<span class="hljs-string">&quot;reverse&quot;</span>,wrap_reverse,METH_VARARGS,<span class="hljs-string">&quot;reverse string&quot;</span>&#125;,<br>  &#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125; <br>&#125;; <br><br><span class="hljs-comment">// 将上面的函数接口打包成example模块(注意函数名需要是initxxx，xxx是模块名)</span><br><span class="hljs-comment">// 且必须是c形式的函数</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initexample</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    PyObject* m; <br>    m = <span class="hljs-built_in">Py_InitModule</span>(<span class="hljs-string">&quot;example&quot;</span>, exampleMethods); <br>&#125;<br></code></pre></td></tr></table></figure><p>将test.c编译成so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fPIC test.c -o example.so -shared  -I /usr/include/python2.7<br></code></pre></td></tr></table></figure><p>python中调用c++方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> example<br><span class="hljs-built_in">print</span> example.fab(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span> example.reverse(<span class="hljs-string">&quot;xujiwei&quot;</span>)<br></code></pre></td></tr></table></figure><p>使用python扩展可以看到，原生c++方法需要先被wrap_fab封装成python可调用的外部方法，然后打包到模块中</p><p><img src="/MyBlog/images/20221215114050image.png"></p><p>第二种方法是调用Python的自有模块ctypes，其中cdll &#x3D; &lt;ctypes.LibraryLoader object&gt;是一个库加载器对象，调用cdll.LoadLibrary便可调用C++的so库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//test1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123; <span class="hljs-comment">// 重要，因为使用g++编译时函数名会改变，比方print_msg(const char*)</span><br>            <span class="hljs-comment">// 会编译成函数名 print_msg_char，这会导致python调用这个函数的时候</span><br>            <span class="hljs-comment">// 找不到对应的函数名，这有加了 extern &quot;C&quot;，才会以C语言的方式进行</span><br>            <span class="hljs-comment">// 编译，这样不会改变函数名字</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_msg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span><br><span class="hljs-function">        </span>&#123;<br>           std::cout&lt;&lt;s&lt;&lt;std::endl;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_Integer</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">return</span> a+b;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -fPIC test1.cpp -o example.so -shared  -I/usr/include/python2.7<br></code></pre></td></tr></table></figure><p>注意c++代码要用g++编译，用gcc编译完加载so的时候可能会报错OSError: &#x2F;mnt&#x2F;e&#x2F;workspace&#x2F;zx&#x2F;test_python_cpp&#x2F;example2.so: undefined symbol: <em>ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6</em></p><p>原因是gcc不会链接C++的库文件，比如std</p><p>python中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>sotest = cdll.LoadLibrary(os.getcwd()+<span class="hljs-string">&quot;/example2.so&quot;</span>)<br>sotest.print_msg(<span class="hljs-string">&quot;hhhhh&quot;</span>)<br>sotest.add_Integer(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><img src="/MyBlog/images/20221215152721image.png"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用小工具集</title>
    <link href="/MyBlog/2022/10/13/%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/MyBlog/2022/10/13/%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-递归删除指定文件"><a href="#1-递归删除指定文件" class="headerlink" title="1.递归删除指定文件"></a>1.递归删除指定文件</h1><p>起因是python3每次运行完会自动生成一堆__pycache__文件夹。这里希望把这些多余的文件夹已经对应的pyc文件都删除掉，作为程序员，让我手动删除是不可能的，于是写了几行代码搞定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> shutil<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">filepath</span>):<br>  files = os.listdir(filepath)<br>  <span class="hljs-keyword">for</span> fi <span class="hljs-keyword">in</span> files:<br>    fi_d = os.path.join(filepath, fi) <br>    <span class="hljs-keyword">if</span> os.path.isdir(fi_d):<br>        <span class="hljs-keyword">if</span> fi == <span class="hljs-string">&quot;__pycache__&quot;</span>:<br>            shutil.rmtree(fi_d) <span class="hljs-comment"># 删除非空文件夹要用这个</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;delete_dir:&#x27;</span>, fi_d)<br>        <span class="hljs-keyword">else</span>:<br>            main(fi_d)  <br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> fi[-<span class="hljs-number">3</span>:] == <span class="hljs-string">&quot;.pyc&quot;</span>:<br>            os.remove(fi_d)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;delete_file:&#x27;</span>, fi_d)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    parent_dir = sys.argv[<span class="hljs-number">1</span>]<br>    cur = os.path.abspath(os.getcwd())<br>    <span class="hljs-built_in">print</span>(cur)<br>    p_dir = cur + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-built_in">str</span>(parent_dir) + <span class="hljs-string">&#x27;/&#x27;</span><br>    main(p_dir)<br><br></code></pre></td></tr></table></figure><p>main(filepath)首先函数通过os.listdir()拿到对应文件夹下的所有文件，如果对应文件是文件夹则判断是否是目标文件夹；其他关联函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.remove(file) <span class="hljs-comment"># 删除文件</span><br>os.removedirs(path) <span class="hljs-comment"># 删除空文件夹</span><br>os.rmdir(path) <span class="hljs-comment"># 删除空文件夹</span><br>shutil.rmtree(path) <span class="hljs-comment"># 删除非空文件夹</span><br></code></pre></td></tr></table></figure><h1 id="2-git切分支小工具"><a href="#2-git切分支小工具" class="headerlink" title="2. git切分支小工具"></a>2. git切分支小工具</h1><p>工作中经常会碰到各个开发分支直接切换的问题，可以通过python pysvn库将多个操作打包到一起，省去繁琐的手动操作提高工作效率。<br>此外我们有时候只几个分支别名：比如trunk&#x2F;release; 它的真实分支可能需要从其他地方拿取（例如我们通过svn外链拿到release的真实分支）然后再进行切换，此时使用工具是比较好的办法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><br>git_branchs = &#123;&#125;<br>DEFAULT = <span class="hljs-string">&#x27;\033[0m&#x27;</span><br>HEADER = <span class="hljs-string">&#x27;\033[95m&#x27;</span><br>RED = <span class="hljs-string">&#x27;\033[31m&#x27;</span>  <br>GREEN = <span class="hljs-string">&#x27;\033[32m&#x27;</span> <br>OKBLUE = <span class="hljs-string">&#x27;\033[94m&#x27;</span><br>OKGREEN = <span class="hljs-string">&#x27;\033[92m&#x27;</span><br>WARNING = <span class="hljs-string">&#x27;\033[93m&#x27;</span><br>FAIL = <span class="hljs-string">&#x27;\033[91m&#x27;</span><br>BOLD = <span class="hljs-string">&#x27;\033[1m&#x27;</span><br>UNDERLINE = <span class="hljs-string">&#x27;\033[4m&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remote_update</span>(<span class="hljs-params">branch_name</span>):<br>    <span class="hljs-keyword">if</span> branch_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> git_branchs:<br>        cmd = <span class="hljs-string">&#x27;git remote update&#x27;</span><br>        os.system(cmd)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_real_branch</span>(<span class="hljs-params">key</span>):<br>    <span class="hljs-keyword">import</span> pysvn<br>    branch = branch_names.get(key)<br>    client = pysvn.client()<br>    ext = client.propget(<span class="hljs-string">&quot;svn:externals&quot;</span>, branch)<br>    ext_url = ext.values()[<span class="hljs-number">0</span>]<br>    m = re.match(<span class="hljs-string">&quot;.*(xxxx_[0-9]*_[0-9]*)/&quot;</span>, ext_url)<br>    <span class="hljs-built_in">print</span> m.group(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> m.group(<span class="hljs-number">1</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkout_branch</span>(<span class="hljs-params">branch_name</span>):<br>    cmd = <span class="hljs-string">&#x27;git rev-parse --verify %s&#x27;</span>%branch_name<br>    res = os.popen(cmd).read()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(FAIL+<span class="hljs-string">&#x27;NOT FOUND &#x27;</span>+DEFAULT+<span class="hljs-string">&#x27;in local branches, try update remote...&#x27;</span>)<br>        cmd = <span class="hljs-string">&#x27;git remote update&#x27;</span><br>        os.system(cmd)<br>        remote_branch_name = <span class="hljs-string">&#x27;refs/remotes/origin/&#x27;</span>+ branch_name<br>        <span class="hljs-built_in">print</span> remote_branch_name<br>        cmd = <span class="hljs-string">&#x27;git rev-parse --verify %s&#x27;</span>%remote_branch_name<br>        res = os.popen(cmd).read()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>            <span class="hljs-built_in">print</span>(RED+<span class="hljs-string">&#x27;ERROR &#x27;</span>+DEFAULT+<span class="hljs-string">&#x27;branch name:%s not found in remote&#x27;</span>%branch_name)<br>            exit(<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-built_in">print</span>(GREEN + <span class="hljs-string">&#x27;checkouting....:&#x27;</span>+ DEFAULT + <span class="hljs-built_in">str</span>(branch_name))<br>    cmd = <span class="hljs-string">&#x27;git checkout %s&#x27;</span>%branch_name<br>    res = os.popen(cmd).read()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(RED+<span class="hljs-string">&#x27;ERROR &#x27;</span>+ DEFAULT + <span class="hljs-string">&#x27;local dirty&#x27;</span>)<br>        exit(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(GREEN + <span class="hljs-string">&#x27;updating branch:&#x27;</span>+ DEFAULT+ (<span class="hljs-built_in">str</span>(branch_name))+<span class="hljs-string">&#x27;....&#x27;</span> )<br>    cmd = <span class="hljs-string">&#x27;git pull&#x27;</span><br>    os.system(cmd)<br>    <span class="hljs-built_in">print</span>(GREEN +<span class="hljs-string">&#x27;SUCCESS switch to branch&#x27;</span> + DEFAULT + <span class="hljs-string">&#x27;.&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    os.system(<span class="hljs-string">&#x27;&#x27;</span>)<br>    branch_name = sys.argv[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> branch_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;trunk&#x27;</span>, <span class="hljs-string">&#x27;release&#x27;</span>]:<br>        branch_name = get_real_branch(branch_name)<br>    checkout_branch(branch_name)<br></code></pre></td></tr></table></figure><p>上述代码主要通过os.system(cmd)以及os.popen(cmd).read()来执行命令行操作，两者均是阻塞形式，后者可以得到返回结果；此外这里通过GREEN、RED等标记对print日志区分颜色可以更加及时的发现问题，有意思的是在调用颜色标记的时候发现不生效，必须在开始的时候调用一次os.systeam(‘’)空命令。 </p><h1 id="3-画图"><a href="#3-画图" class="headerlink" title="3.画图"></a>3.画图</h1><p>python matplotlib.pyplot是一个非常实用的画图小工具, 可以画折线图、柱状图、饼状图等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sys  <br>reload(sys)  <br>sys.setdefaultencoding(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>]=[<span class="hljs-string">&#x27;SimHei&#x27;</span>] <span class="hljs-comment">#用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span> <span class="hljs-comment">#用来正常显示负号</span><br><br>city_list = [<span class="hljs-string">&#x27;黑龙江省&#x27;</span>,<span class="hljs-string">&#x27;宁夏&#x27;</span>,<span class="hljs-string">&#x27;辽宁省&#x27;</span>,<span class="hljs-string">&#x27;山西省&#x27;</span>,<span class="hljs-string">&#x27;河北省&#x27;</span>,<span class="hljs-string">&#x27;天津&#x27;</span>,<span class="hljs-string">&#x27;山东省&#x27;</span>,<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-string">&#x27;内蒙古&#x27;</span>,<span class="hljs-string">&#x27;吉林省&#x27;</span>,<span class="hljs-string">&#x27;河南省&#x27;</span>]<br>colors = [<span class="hljs-string">&#x27;go&#x27;</span>, <span class="hljs-string">&#x27;bo&#x27;</span>, <span class="hljs-string">&#x27;ro&#x27;</span>, <span class="hljs-string">&#x27;yo&#x27;</span>, <span class="hljs-string">&#x27;ko&#x27;</span>, <span class="hljs-string">&#x27;wo&#x27;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drow_delay_plot</span>():<br>    <span class="hljs-string">&quot;&quot;&quot; 点图 &quot;&quot;&quot;</span><br>    dian_xin = []<br>    lian_tong = []<br>    yi_dong = []<br>    <span class="hljs-keyword">for</span> i, city <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(city_list):<br>        d = <span class="hljs-number">50</span> + i<br>        dian_xin.append(d)<br>        y = <span class="hljs-number">60</span> + i<br>        yi_dong.append(y)<br>        l = <span class="hljs-number">70</span> + i<br>        lian_tong.append(l)<br>    <span class="hljs-comment"># 此次绘制多个点</span><br>    plt.plot(city_list, yi_dong, colors[<span class="hljs-number">0</span>], label=<span class="hljs-string">&quot;移动&quot;</span>)<br>    plt.plot(city_list, lian_tong, colors[<span class="hljs-number">1</span>], label=<span class="hljs-string">&quot;联通&quot;</span>)<br>    plt.plot(city_list, dian_xin, colors[<span class="hljs-number">2</span>], label=<span class="hljs-string">&quot;电信&quot;</span>)  <br>    <br>    plt.legend(loc=<span class="hljs-string">&#x27;upper right&#x27;</span>, shadow=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 注解放到右上角</span><br>    plt.xlabel(<span class="hljs-string">&#x27;city&#x27;</span>) <span class="hljs-comment">#设置x轴名称 x label</span><br>    plt.ylabel(<span class="hljs-string">&#x27;delay(ms)&#x27;</span>) <span class="hljs-comment">#设置y轴名称 y label</span><br>    title = <span class="hljs-string">&quot;网络延迟分布&quot;</span>.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 设置标题</span><br>    plt.title(title)<br>    plt.show()<br>      <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drow_plot_total</span>():<br>    <span class="hljs-string">&quot;&quot;&quot; 柱状图 &quot;&quot;&quot;</span><br>    X = city_list<br>    Y = []<br>    <span class="hljs-keyword">for</span> i, city <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(city_list):<br>        y = <span class="hljs-number">1000.0</span>/ (i+<span class="hljs-number">1</span>) * random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>        Y.append(y)<br>    plt.bar(X, Y, fc=<span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-comment"># 绘制横坐标和纵坐标说明</span><br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X,Y):  <br>        plt.text(a, b+<span class="hljs-number">0.05</span>, <span class="hljs-string">&#x27;%.2f&#x27;</span> % b, ha=<span class="hljs-string">&#x27;center&#x27;</span>, va= <span class="hljs-string">&#x27;bottom&#x27;</span>,fontsize=<span class="hljs-number">9</span>) <br>    plt.ylabel(<span class="hljs-string">&#x27;cnt&#x27;</span>) <span class="hljs-comment">#设置y轴名称 y label</span><br>    title = <span class="hljs-string">&quot;城市人数分布&quot;</span>.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    plt.title(title)<br>    plt.show()<br></code></pre></td></tr></table></figure><p>这里面需要最容易踩的坑就是输出中文.<br>网络延迟分布图如下所示： 另外可通过’bo’等标记后面加’-‘将点图改成折线图<br><img src="/MyBlog/images/delay.png"><br>城市人数分布柱状图如下：<br><img src="/MyBlog/images/player_cnt.png"><br>这里只展示了matplotlib.pyplot的基础操作，还有很多进阶用法可自行百度。</p><p>[未完待续…]</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次python性能追查</title>
    <link href="/MyBlog/2022/08/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1python%E6%80%A7%E8%83%BD%E8%BF%BD%E6%9F%A5/"/>
    <url>/MyBlog/2022/08/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1python%E6%80%A7%E8%83%BD%E8%BF%BD%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p>本案例代码逻辑较为简单，主要记录了从python源码排查问题的过程以及python性能分析工具的使用。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做战斗服负载均衡的时候有个场景需要从一个list中查找并删掉一个元素，大多数人可能会跟我一样选择内置函数remove，核心代码如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_with_inter_func</span>(<span class="hljs-params">ll, value</span>):<br>    <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> ll: <br>        ll.remove(value)<br></code></pre></td></tr></table></figure><p>考虑到python list是个线性结构，in操作和remove操作的时间复杂度均为**O(n)**，那上述操作岂不是要遍历两次list，由于是匹配服跑的逻辑，对cpu性能要求较高，如果list比较长，两次遍历也是一件很蠢的事情，下面直接从源码（python2.7.11版本）来看上述问题。</p><h2 id="List内部实现"><a href="#List内部实现" class="headerlink" title="List内部实现"></a>List内部实现</h2><p><em>list</em> 对象在 <em>Python</em> 内部，由 <em>PyListObject</em> 结构体表示，定义于头文件 <em>Include&#x2F;listobject.h</em> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_VAR_HEAD<br>    <span class="hljs-comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span><br>    PyObject **ob_item;<br><br>    <span class="hljs-comment">/* ob_item contains space for &#x27;allocated&#x27; elements.  The number</span><br><span class="hljs-comment">     * currently in use is ob_size.</span><br><span class="hljs-comment">     * Invariants:</span><br><span class="hljs-comment">     *     0 &lt;= ob_size &lt;= allocated</span><br><span class="hljs-comment">     *     len(list) == ob_size</span><br><span class="hljs-comment">     *     ob_item == NULL implies ob_size == allocated == 0</span><br><span class="hljs-comment">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Items must normally not be NULL, except during construction when</span><br><span class="hljs-comment">     * the list is not yet visible outside the function that builds it.</span><br><span class="hljs-comment">     */</span><br>    Py_ssize_t allocated;<br>&#125; PyListObject;<br></code></pre></td></tr></table></figure><p><em>list</em> 对象是一种 <strong>变长对象</strong> ，因此包含变长对象公共头部。除了公共头部， <em>list</em> 内部维护了一个动态数组，而数组则依次保存元素对象的指针：</p><ul><li><em>ob_item</em> ，指向动态数组的指针，动态数组保存元素对象的指针；</li><li><em>allocated</em> ，动态数组长度，即列表 <strong>容量</strong> ；</li><li><em>ob_size</em> ，动态数组当前保存元素个数，即列表 <strong>长度</strong> ；</li></ul><h3 id="in操作源码"><a href="#in操作源码" class="headerlink" title="in操作源码"></a>in操作源码</h3><p>python中in操作用来判断某个元素是否在**ob_item数组中，其源码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">list_contains</span><span class="hljs-params">(PyListObject *a, PyObject *el)</span><br>&#123;<br>    Py_ssize_t i;<br>    <span class="hljs-type">int</span> cmp;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, cmp = <span class="hljs-number">0</span> ; cmp == <span class="hljs-number">0</span> &amp;&amp; i &lt; Py_SIZE(a); ++i)<br>        cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),<br>                                           Py_EQ);<br>    <span class="hljs-keyword">return</span> cmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中cmp &#x3D; PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i)判断数组a中的第i个元素是否跟el这个对象相等, 相等返回1，不相等返回0，错误返回-1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Return -1 if error; 1 if v op w; 0 if not (v op w). */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">PyObject_RichCompareBool</span><span class="hljs-params">(PyObject *v, PyObject *w, <span class="hljs-type">int</span> op)</span><br>&#123;<br>    PyObject *res;<br>    <span class="hljs-type">int</span> ok;<br><br>    <span class="hljs-comment">/* Quick result when objects are the same.</span><br><span class="hljs-comment">       Guarantees that identity implies equality. */</span><br>    <span class="hljs-keyword">if</span> (v == w) &#123;<br>        <span class="hljs-keyword">if</span> (op == Py_EQ)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == Py_NE)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    res = PyObject_RichCompare(v, w, op);<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (PyBool_Check(res))<br>        ok = (res == Py_True);<br>    <span class="hljs-keyword">else</span><br>        ok = PyObject_IsTrue(res);<br>    Py_DECREF(res);<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure><p>PyList_GET_ITEM操作更简单，就是从ob_item中取出第i个元素，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])</span><br></code></pre></td></tr></table></figure><p>上面的list_contains代码可以理解为：for循环判断PyListObject *a中的元素，如果与el不相等则cmp为0继续遍历直到遍历到cmp为1为止。很显然，in操作需要遍历一次ob_item列表。</p><h3 id="remove源码"><a href="#remove源码" class="headerlink" title="remove源码"></a>remove源码</h3><p>再来看下remove操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> PyObject *<br><span class="hljs-title function_">listremove</span><span class="hljs-params">(PyListObject *self, PyObject *v)</span><br>&#123;<br>    Py_ssize_t i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Py_SIZE(self); i++) &#123;<br>        <span class="hljs-type">int</span> cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);<br>        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list_ass_slice(self, i, i+<span class="hljs-number">1</span>,<br>                               (PyObject *)<span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>)<br>                Py_RETURN_NONE;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    PyErr_SetString(PyExc_ValueError, <span class="hljs-string">&quot;list.remove(x): x not in list&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove操作也是一次遍历，先通过PyObject_RichCompareBool判断第i个元素与v是否相等，cmp&#x3D;1则相等，此时调用list_ass_slice进行删除操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">list_ass_slice</span><span class="hljs-params">(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)</span><br>&#123;<br>    PyObject *recycle_on_stack[<span class="hljs-number">8</span>];<br>    PyObject **recycle = recycle_on_stack; <span class="hljs-comment">/* will allocate more if needed */</span><br>    PyObject **item;<br>    PyObject **vitem = <span class="hljs-literal">NULL</span>;<br>    PyObject *v_as_SF = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* PySequence_Fast(v) */</span><br>    Py_ssize_t n; <span class="hljs-comment">/* # of elements in replacement list */</span><br>    Py_ssize_t norig; <span class="hljs-comment">/* # of elements in list getting replaced */</span><br>    Py_ssize_t d; <span class="hljs-comment">/* Change in size */</span><br>    Py_ssize_t k;<br>    <span class="hljs-type">size_t</span> s;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;            <span class="hljs-comment">/* guilty until proved innocent */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> b ((PyListObject *)v)</span><br>    <span class="hljs-keyword">if</span> (v == <span class="hljs-literal">NULL</span>)<br>        n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>       ...<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ilow &lt; <span class="hljs-number">0</span>)<br>        ilow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ilow &gt; Py_SIZE(a))<br>        ilow = Py_SIZE(a);<br><br>    <span class="hljs-keyword">if</span> (ihigh &lt; ilow)<br>        ihigh = ilow;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ihigh &gt; Py_SIZE(a))<br>        ihigh = Py_SIZE(a);<br><br>    norig = ihigh - ilow;<br>    assert(norig &gt;= <span class="hljs-number">0</span>);<br>    d = n - norig;<br>    <span class="hljs-keyword">if</span> (Py_SIZE(a) + d == <span class="hljs-number">0</span>) &#123;<br>        ...<br>    &#125;<br>    item = a-&gt;ob_item;<br><br>    <span class="hljs-comment">// 将需要删除的元素移动到recycle数组中</span><br>    s = norig * <span class="hljs-keyword">sizeof</span>(PyObject *);<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-keyword">sizeof</span>(recycle_on_stack)) &#123;<br>        recycle = (PyObject **)PyMem_MALLOC(s);<br>        <span class="hljs-keyword">if</span> (recycle == <span class="hljs-literal">NULL</span>) &#123;<br>            PyErr_NoMemory();<br>            <span class="hljs-keyword">goto</span> Error;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(recycle, &amp;item[ilow], s);<br><br>    <span class="hljs-comment">// 实际删除操作的代码，此时d为-1，将item[ihigh]即之后的元素移动到item[ihigh+d]开始的地方，并重新计算a的大小</span><br>    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Delete -d items */</span><br>        memmove(&amp;item[ihigh+d], &amp;item[ihigh],<br>            (Py_SIZE(a) - ihigh)*<span class="hljs-keyword">sizeof</span>(PyObject *));<br>        list_resize(a, Py_SIZE(a) + d);<br>        item = a-&gt;ob_item;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Insert d items */</span><br>       ...<br>    &#125;<br>    <span class="hljs-comment">// 调整引用计数</span><br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; n; k++, ilow++) &#123;<br>        PyObject *w = vitem[k];<br>        Py_XINCREF(w);<br>        item[ilow] = w;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (k = norig - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; --k)<br>        Py_XDECREF(recycle[k]);<br>    result = <span class="hljs-number">0</span>;<br> Error:<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> b</span><br>&#125;<br></code></pre></td></tr></table></figure><p>list_ass_slice源码较长，它不仅可以用来从list中删除部分元素，还可以用来进行插入操作，通过参数v是否为NULL来判断是执行删除还是插入，上面省略了插入相关的代码。</p><p>上述代码也可以简单理解为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[ilow:ihigh]</span> = v <span class="hljs-keyword">if</span> v != NULL<br><span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[ilow:ihigh]</span> <span class="hljs-keyword">if</span> v == NULL<br></code></pre></td></tr></table></figure><p>在PyListObject中，如果是在列表中部删除元素的话，一定会引起内存的搬移动作，这一点跟 C++中的 vector 是完全一致的，而与 C++中的 list 不同。</p><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>既然内置函数有冗余的地方，我们可以很简单的通过一次遍历实现相同的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_custom</span>(<span class="hljs-params">ll, value</span>):<br>    s = <span class="hljs-built_in">len</span>(ll)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(s):<br>        <span class="hljs-keyword">if</span> ll[j] != value: <br>            <span class="hljs-keyword">continue</span> <br>        <span class="hljs-keyword">del</span> ll[j]<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这段代码遍历并判断每个元素是否与目标元素相等，如果相等则删除，找到了就break跳出循环。并且代码只用到了xrange()，len()、del等基础操作。</p><p>python ListObejct的len操作实际就是获取ob_size的过程，时间复杂度为O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Py_ssize_t<br><span class="hljs-title function_">PyList_Size</span><span class="hljs-params">(PyObject *op)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!PyList_Check(op)) &#123;<br>        PyErr_BadInternalCall();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Py_SIZE(op);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Py_SIZE(ob)  (((PyVarObject*)(ob))-&gt;ob_size)</span><br></code></pre></td></tr></table></figure><p>理论上一次遍历的代码会优于内置的in+remove方法，下面进行一下简单的测试（文末附完整测试代码）, 我们构造一个10000个元素的list并通过两种实现各调用1000次，查看运行时间对比：</p><p><img src="/MyBlog/images/1.png"></p><p>通过测试发现一次遍历消耗的时间居然比in+remove还要慢，这让我难以理解。上述代码中process_list[j] !&#x3D; value最终调用到PyObject_RichCompareBool操作，而del process_list[j]也是同list_ass_slice相似的memmove操作，为什么性能反而不如in+remove的两次遍历呢？ 为搞清楚这一问题，我们需要进行一些性能追查。</p><h2 id="性能追查"><a href="#性能追查" class="headerlink" title="性能追查"></a>性能追查</h2><p>首先，采用cPorfile对上述脚本进行性能分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m cProfile -o test_del.out test_del.py<br></code></pre></td></tr></table></figure><p>采用pstats查看结果，并按照消耗时间time排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&quot;import pstats; p=pstats.Stats(&#x27;test_del.out&#x27;); p.sort_stats(&#x27;time&#x27;).print_stats()&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/MyBlog/images/2.png"></p><p>这里打印出了各个函数调用的次数以及占用的时间，但是结果不够直观。我们继续通过火焰图形式显示函数调用栈：（需要安装flameprof）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install flameprof <span class="hljs-comment"># 安装flameprof</span><br><span class="hljs-comment"># 去python/Lib/site-packages中找到flameprof.py</span><br>python flameprof.py test_del.out &gt; test_del.svg<br></code></pre></td></tr></table></figure><p>然后浏览器打开test_del.svg结果如下图所示：</p><p><img src="/MyBlog/images/3.png"></p><p>火焰图能看到各个函数调用时间占比，但调用栈似乎显示不全，我们改用Qcachegrind(Kcachegrind)查阅表格化结果。</p><p>Qcachegrind读取的文件格式是callgrind格式，不能直接支持python生成的profile记录。因此需要先使用pyprof2calltree工具进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pyprof2calltree <span class="hljs-comment"># 如果没安装的话</span><br>pyprof2calltree -i test_del.out <span class="hljs-comment">#会生成一个test_del.out.log文件</span><br></code></pre></td></tr></table></figure><p>用Qcachegrind打开test_del.out.log文件, 如果没有可以先去下面的连接下载然后解压到文件夹，双击qcachegrind.exe运行，然后打开test_del.out.log文件即可。</p><p><a href="https://sourceforge.net/projects/qcachegrindwin/?source=typ_redirect">QCacheGrind 包体下载</a></p><p><img src="/MyBlog/images/4.png"></p><p>通过上面的分析可以看出，del_custom中唯一的函数调用len()虽然调用了1000次，但运行时间占比只有0.01%，并不是性能损耗的关键。难道问题出在参数传递的过程中？</p><p>我们保留len()函数调用，但将遍历的list长度改为固定值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_custom2</span>(<span class="hljs-params">ll, value</span>):<br>    s = <span class="hljs-built_in">len</span>(ll)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">999</span>):<br>        <span class="hljs-keyword">if</span> ll[j] != value: <br>            <span class="hljs-keyword">continue</span> <br>        <span class="hljs-keyword">del</span> ll[j]<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>然后运行发现耗时直接下降了一个数量级</p><p><img src="/MyBlog/images/5.png"></p><p>针对del_custom和del_custom2我们来看下运行的指令码：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">import <span class="hljs-keyword">dis</span><br><span class="hljs-keyword">dis</span>.<span class="hljs-keyword">dis</span>(del_custom)<br><span class="hljs-keyword">dis</span>.<span class="hljs-keyword">dis</span>(del_custom2)<br></code></pre></td></tr></table></figure><p><img src="/MyBlog/images/6.png" alt="2022-07-21-17-47-03-image.png"></p><p><img src="/MyBlog/images/7.png"></p><p>发现del_custom和del_custom2指令码唯一的区别在上图箭头所在位置 LOAD_FAST 和LOAD_CONST。接下来直接去ceval.c查找下这两个指令的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ceval.c</span><br><span class="hljs-comment">// LOAD_FAST</span><br>TARGET(LOAD_FAST)<br>&#123;<br>    x = GETLOCAL(oparg); <span class="hljs-comment">// 从f-&gt;f_localsplus中获取第i个元素</span><br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">NULL</span>) &#123;<br>        Py_INCREF(x);<br>        PUSH(x);<br>        FAST_DISPATCH();<br>    &#125;<br>    format_exc_check_arg(PyExc_UnboundLocalError,<br>        UNBOUNDLOCAL_ERROR_MSG,<br>        PyTuple_GetItem(co-&gt;co_varnames, oparg));<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// LOAD_CONST</span><br>TARGET(LOAD_CONST)<br>&#123;<br>    x = GETITEM(consts, oparg); <span class="hljs-comment">//从co-&gt;co_consts中获取第i个元素</span><br>    Py_INCREF(x);<br>    PUSH(x);<br>    FAST_DISPATCH();<br>&#125;<br></code></pre></td></tr></table></figure><p>LOAD_FAST相比LOAD_CONST的区别除了LOAD_FAST从f-&gt;f_localsplus中获取局部变量外，还多了一个format_exc_check_arg调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">format_exc_check_arg(PyObject *exc, <span class="hljs-type">char</span> *format_str, PyObject *obj)<br>&#123;<br>    <span class="hljs-type">char</span> *obj_str;<br><br>    <span class="hljs-keyword">if</span> (!obj)<br>        <span class="hljs-keyword">return</span>;<br><br>    obj_str = PyString_AsString(obj);<br>    <span class="hljs-keyword">if</span> (!obj_str)<br>        <span class="hljs-keyword">return</span>;<br><br>    PyErr_Format(exc, format_str, obj_str);<br>&#125;<br></code></pre></td></tr></table></figure><p>在回到原来的原始程序中，基本可以定位len(ll)为性能下降的凶手。len(ll)本身是一次函数调用，在python中函数调用本身会占用一定的时间。而python内置方法在一定程度上拥有足够的性能优化。 本次追查主要是对python源码以及工具使用的一次模拟。</p><h2 id="附完整测试代码"><a href="#附完整测试代码" class="headerlink" title="附完整测试代码"></a>附完整测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_with_inter_func</span>(<span class="hljs-params">ll, value</span>):<br>    <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> ll: <br>        ll.remove(value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_custom</span>(<span class="hljs-params">ll, value</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> xrange(<span class="hljs-built_in">len</span>(ll)):<br>        <span class="hljs-keyword">if</span> ll[j] != value: <br>            <span class="hljs-keyword">continue</span> <br>        <span class="hljs-keyword">del</span> ll[j]<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_del</span>():<br><br>    ll = [<span class="hljs-string">&#x27;test&#x27;</span>+<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">10000</span>)]<br>    t = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)<br>    value = <span class="hljs-string">&#x27;test&#x27;</span>+<span class="hljs-built_in">str</span>(t)<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;begin&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">30</span><br><br>    <span class="hljs-comment"># 内置函数测试</span><br>    t1 = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">1000</span>):<br>        del_with_inter_func(ll, t)<br>    t2 = time.time()<br><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;t1:&#x27;</span>, t2-t1<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">30</span><br><br>    <span class="hljs-comment"># 一次遍历测试</span><br>    ll2 = [<span class="hljs-string">&#x27;test&#x27;</span>+<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">10000</span>)]<br>    t1 = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">1000</span>):<br>        del_custom(ll2, value)<br>    t2 = time.time()<br><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;t2:&#x27;</span>, t2-t1<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">30</span><br><br>test_del()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch学习实践</title>
    <link href="/MyBlog/2022/06/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/MyBlog/2022/06/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>ElasticSearch(以下简称ES)是一个基于Lucene构建的开源，分布式，实时的搜索与分析引擎。用于全文索引、结构化数据索引、数据分析等各方面。</p><p>在应用程序中的对象，不仅仅是简单的keys和values，更多的是由更为复杂的数据结构组成的数据构成的。ES面向文档来存储对象。</p><h2 id="精确索引VS全文索引"><a href="#精确索引VS全文索引" class="headerlink" title="精确索引VS全文索引"></a>精确索引VS全文索引</h2><p>在ES中的数据可以分为两类：精确值(exact values)以及全文(full text)。精确值：例如日期类型date，若date其有两个值:2014-09-15与2014，那么这两个值不相等。又例如字符串类型foo与Foo不相等。 全文：通常是人类语言写的文本，例如一段tweet信息、email的内容等。精确值很容易被索引：一个值要么相当要么不等。 索引全文值就需要很多功夫。ES使用<strong>倒序索引</strong>来加速全文索引。</p><h2 id="倒序索引"><a href="#倒序索引" class="headerlink" title="倒序索引"></a>倒序索引</h2><p>我们传统的检索方式是通过遍历整篇文章，逐个比对找到对应的关键词位置，而倒排索引是通过分词策略，形成词和文章的关系映射表，这种<em>词典+映射表的方式就是倒排索引</em></p><p>为方便全文搜索，ES将每个文档内容按照不同的单词（terms）进行分割，然后创建一个所有terms的列表，并且记录每一个term出现的文档。</p><p>当我们根据单词去搜索文档，我们匹配到了一个term出现的所有文档，但是第一个文档中term出现的次数比第二个文档多，可以认为第一个文档比第二个文档的匹配度要好，因此可以建立简单的按照匹配次数排序的索引算法。</p><h1 id="ES查询简介"><a href="#ES查询简介" class="headerlink" title="ES查询简介"></a>ES查询简介</h1><p>为了介绍ES中一条search请求查询的步骤，我们以下面这条查询操作为例，该查询请求从所有文档中取第100条开始的10条数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">POST /my_index/my_type/_search<br>&#123;<br>    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,<br>    &quot;from&quot;: 100,<br>    &quot;size&quot;:  10<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc，fetch 阶段取出具体的 doc。</p><h2 id="Query阶段"><a href="#Query阶段" class="headerlink" title="Query阶段"></a>Query阶段</h2><p>query阶段主要是从每个shard中获取数据，然后到一个节点上进行全局排序，从而确定最终需要的文档id。</p><ol><li>Client 发送一次搜索请求，node1 接收到请求，然后node1 创建一个大小为 from + size 的优先级队列用来存结果，我们管 node1 叫 coordinating node。</li><li>coordinating node将请求广播到涉及到的 shards，每个 shard 在内部执行搜索请求，然后，将结果存到内部的大小同样为 from + size 的优先级队列里，可以把优先级队列理解为一个包含 top N 结果的列表。</li><li>每个 shard 把暂存在自身优先级队列里的数据返回给 coordinating node，coordinating node 拿到各个 shards 返回的结果后对结果进行一次合并，产生一个全局的优先级队列，存到自身的优先级队列里。</li><li>coordinating node 计算好自己的优先级队列后，query 阶段结束，进入 fetch 阶段。</li></ol><h2 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h2><p>Fetch阶段主要是根据全局排序结果，重新去各个shard上拿数据。</p><ol><li>coordinating node 得到全局排序的top N结果后，依次发送 GET 请求到相关shards。</li><li>shard 根据 doc 的 _id 取到数据详情，然后返回给 coordinating node。</li><li>coordinating node 返回数据给 Client。</li></ol><p>需要取的数据可能在不同分片，也可能在同一分片，coordinating node 使用 <code>multi-get</code> 来避免多次去同一分片取数据，从而提高性能。</p><h2 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h2><p>ES 默认采用的分页方式是 from+ size 的形式，但在某些情况下from+size的查询方式会带来严重的性能问题，例如，在一个索引中有10亿数据，分10个 shards，然后，一个搜索请求，from&#x3D;1,000,000，size&#x3D;100，这时候在 query 阶段，每个shards需要返回 1,000,100 条数据给 coordinating node，而 coordinating node 需要接收 10 * 1,000,100 条数据，这对内存、cpu、网络资源都是一个较大的消耗。</p><p>Elasticsearch 提供了scroll 方式来实现滚动遍历从而避免深度分页问题。</p><h2 id="Search-After深度分页"><a href="#Search-After深度分页" class="headerlink" title="Search After深度分页"></a>Search After深度分页</h2><p>scroll search 的方式，官方的建议不用于实时文档的查询，原因是scroll_id基于历史快照生成，实时变化的数据不会立刻反映到快照上。那么在实时情况下如果处理深度分页的问题呢？es 给出了 search_after 的方式。</p><p>search_after根据上一页的最后一条数据来确定下一页的位置，同时在分页请求的过程中，如果有索引数据的增删改查，这些变更也会实时的反映到游标上。</p><p>使用search_after需要注意的是，为了找到每一页最后一条数据，每个文档必须有一个全局唯一值，官方推荐使用 _id 作为全局唯一值；需要排序；设置from&#x3D;0；第二页查询时需要将第一页最后一条数据传进去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">POST /my_index/my_type/_search<br>&#123;<br>  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,<br>  &quot;size&quot;: 10,<br>  &quot;from&quot;: 0,<br>  &quot;search_after&quot;: [<br>    1541495312521,<br>    &quot;d0xH6GYBBtbwbQSP0j1A&quot;<br>  ],<br>  &quot;sort&quot;: [<br>    &#123;<br>      &quot;timestamp&quot;: &#123;<br>        &quot;order&quot;: &quot;desc&quot;<br>      &#125;,<br>      &quot;_id&quot;: &#123;<br>        &quot;order&quot;: &quot;desc&quot;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="python实践"><a href="#python实践" class="headerlink" title="python实践"></a>python实践</h1><p>线上服务器会将报错内容保存成ES文档，客户端可通过ES请求筛选并拉取各种报错。</p><h2 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h2><p>我是用的是python2.7，直接pip安装python库就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install elasticsearch (7.11.0)<br></code></pre></td></tr></table></figure><h2 id="创建一个到ES服务集群的连接"><a href="#创建一个到ES服务集群的连接" class="headerlink" title="创建一个到ES服务集群的连接"></a>创建一个到ES服务集群的连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> Elasticsearch, ConnectionTimeout<br><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> helpers<br><span class="hljs-keyword">from</span> elasticsearch.compat <span class="hljs-keyword">import</span> urlencode<br><span class="hljs-keyword">from</span> elasticsearch.connection <span class="hljs-keyword">import</span> RequestsHttpConnection<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthToken</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    TOKEN AUTH BASE CLASS</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, token</span>):<br>        self.headers = &#123;<br>            <span class="hljs-string">&#x27;ELK-AUTH-TOKEN&#x27;</span>: token<br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, r</span>):<br>        r.headers.update(self.headers)<br>        <span class="hljs-keyword">return</span> r<br><br>es = Elasticsearch(host=host_url, port=xxx, connection_class=RequestsHttpConnection, http_auth=AuthToken(My_token))<br></code></pre></td></tr></table></figure><h2 id="采用search拉取"><a href="#采用search拉取" class="headerlink" title="采用search拉取"></a>采用search拉取</h2><p>基于python ES api，我们可以采用es.search拉取所有满足筛选条件的文档，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过http请求拉取</span><br>page = es.search(index=my_index, body=body, scroll=<span class="hljs-string">&quot;2m&quot;</span>, size=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>上述接口在所有文档中搜索并返回最多50条数据，其中scroll&#x3D;‘2m’表示滚动查询，上下文数据缓存时间未2分钟；</p><p>search参数说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">常用参数<br>index - 索引名<br>q - 查询指定匹配 使用Lucene查询语法<br>from_ - 查询起始点  默认<span class="hljs-number">0</span><br>doc_type - 文档类型<br>size - 指定查询条数 默认<span class="hljs-number">10</span><br>field - 指定字段 逗号分隔<br>sort - 排序  字段：asc/desc<br>body - 使用Query DSL<br>scroll - 滚动查询<br></code></pre></td></tr></table></figure><p>筛选条件放到body中，具体的规则参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/query-dsl-query-string-query.html#query-string-syntax">Elasticsearch Guide [6.7] | Elastic</a></p><p>采用es.search时会返回一个当前游标id：scroll_id记录上一次查询扫描过的文档，如果下一次想要接着上一次的查询，则可以直接使用es.scroll(scroll_id&#x3D;scroll_id, scroll &#x3D;’2m’), 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">page = self.es.search(index=self.index, body=body, scroll=<span class="hljs-string">&quot;2m&quot;</span>, size=page_size)<br>scroll_id = page[<span class="hljs-string">&#x27;_scroll_id&#x27;</span>]  <span class="hljs-comment"># 获取scrollID</span><br>total = page[<span class="hljs-string">&#x27;hits&#x27;</span>][<span class="hljs-string">&#x27;total&#x27;</span>].get(<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 数据的总条数</span><br>source_info = &#123;&#125;<br><span class="hljs-comment"># 第一页也要加到数据里去</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> page[<span class="hljs-string">&quot;hits&quot;</span>][<span class="hljs-string">&quot;hits&quot;</span>]:<br>    source = i.get(<span class="hljs-string">&quot;_source&quot;</span>, &#123;&#125;)<br>    <span class="hljs-built_in">id</span> = i.get(<span class="hljs-string">&#x27;_id&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span>: source_info[<span class="hljs-built_in">id</span>] = source<br><span class="hljs-comment"># Start scrolling</span><br><span class="hljs-keyword">while</span>(total &gt; <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Scrolling...&quot;</span>, scroll_id<br>    page = self.es.scroll(scroll_id=scroll_id, scroll =<span class="hljs-string">&#x27;2m&#x27;</span>)<br>    <span class="hljs-comment"># 更新scroll——id</span><br>    scroll_id = page[<span class="hljs-string">&#x27;_scroll_id&#x27;</span>]<br>    total = <span class="hljs-built_in">len</span>(page[<span class="hljs-string">&#x27;hits&#x27;</span>][<span class="hljs-string">&#x27;hits&#x27;</span>])<br>    <span class="hljs-comment"># 把当前页加到查询结果里面去</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> page[<span class="hljs-string">&quot;hits&quot;</span>][<span class="hljs-string">&quot;hits&quot;</span>]:<br>        source = i.get(<span class="hljs-string">&quot;_source&quot;</span>, &#123;&#125;)<br>        <span class="hljs-built_in">id</span> = i.get(<span class="hljs-string">&#x27;_id&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span>: source_info[<span class="hljs-built_in">id</span>] = source<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;data_len:&#x27;</span>, <span class="hljs-built_in">len</span>(source_info)<br><span class="hljs-keyword">return</span> source_info<br></code></pre></td></tr></table></figure><h2 id="通过scan分批次拉取"><a href="#通过scan分批次拉取" class="headerlink" title="通过scan分批次拉取"></a>通过scan分批次拉取</h2><p>另外我们也可以通过helpers.scan来分批返回结果，采用scan无需手动更新scroll_id，配合yield迭代查询效果更佳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">self.es = Elasticsearch(host=self.trace_url, port=xxx, connection_class=RequestsHttpConnection, http_auth=AuthToken(self.token))<br>start_ts, end_ts = self.parse_time_args(start, end)<br>query = self.get_body(start_ts, end_ts)<br><span class="hljs-comment"># 分页拉取，每页100条, 页数等于该时间段总日志数/100 + 1</span><br>results = helpers.scan(client=self.es, query=query, scroll=<span class="hljs-string">&#x27;2m&#x27;</span>, index=self.index, size=<span class="hljs-number">100</span>)<br>ids = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">for</span> hitobj <span class="hljs-keyword">in</span> results:<br>   source = hitobj.get(<span class="hljs-string">&quot;_source&quot;</span>, &#123;&#125;)<br>   <span class="hljs-built_in">id</span> = hitobj.get(<span class="hljs-string">&#x27;_id&#x27;</span>)<br>   ids.add(<span class="hljs-built_in">id</span>)<br>   <span class="hljs-keyword">yield</span> source<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃表skiplist</title>
    <link href="/MyBlog/2022/06/10/%E8%B7%B3%E8%B7%83%E8%A1%A8skiplist/"/>
    <url>/MyBlog/2022/06/10/%E8%B7%B3%E8%B7%83%E8%A1%A8skiplist/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃表SkipList"><a href="#跳跃表SkipList" class="headerlink" title="跳跃表SkipList"></a>跳跃表SkipList</h1><p>跳跃表是一种查询效率很高的数据结构，平均查找和插入时间复杂度都是O(log n)，最常见的应用场景如排行榜，Redis中zset就是采用跳跃表实现。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>跳跃表的性能堪比红黑树，而且实现起来比红黑树简单很多。那么什么是跳跃表？理解跳跃表前我们先看一个基单链表结构。</p><p><img src="https://img-blog.csdnimg.cn/20210317082630470.png" alt="单链表结构原理"></p><p>假如我们要查询值为 13的节点，对于上面的单向链表来说，我需要从前往后遍历节点，算一下要进行 10 次查找，性能是非常差的，如何提升查询速度？我们知道即使有序的链表也是没变法进行二分查找的，除非我们把这个链表变成红黑树这样的结构，但是红黑树实现起来太过麻烦。所以，如果我把这个链表像这样处理一下呢？</p><p><img src="https://img-blog.csdnimg.cn/20210317082645182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0OTQxNDg=,size_16,color_FFFFFF,t_70" alt="两层跳跃表结构原理"></p><p>我把第一层链表中的元素，每隔2个元素就向上提取一个元素，形成第二层的链表，如上图，如果我查找元素的时候先从最上面的层级找 13 ，当找到 18的时候大于13，就退回10，往下一层找，然后就找到13了，你数一下这一次的查找次数几乎是之前的单向链表的一半，大大节省了查询时间。那如果我再往上抽取一层呢？</p><p><img src="https://img-blog.csdnimg.cn/20210317082724541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0OTQxNDg=,size_16,color_FFFFFF,t_70" alt="三层跳跃表结构原理"></p><p>按照刚才的规律，我们再向上抽取一层，这一次查找的次数是不是又变少了？其实这种数据结构就是“跳跃表”的存储结构了。其实你可以发现他的查询性能是可以媲美红黑树的，但是实现起来比红黑树简单许多。</p><h2 id="随机层数"><a href="#随机层数" class="headerlink" title="随机层数"></a>随机层数</h2><p>跳表引入了随机深度的机制，也就是一个结点能够出现的层数数量是随机的。并且所有的跳表结点都出现在第一层中，当某结点出现在第i层，那么它一定出现在第i-1层，我们假设该结点出现在第i+1层的概率为p, 则对于任意一个结点, 它只有1层的概率为（1-p），有两层的概率为p(1-p)，因此跳跃表的层数概率期望：</p><p><img src="https://www.shouxicto.com/zb_users/upload/2021/10/20211007091744163356946420519.webp" alt="跳跃表随机层数概率期望"></p><p>Redis中设定：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">p = 1/4<br>MaxLevel = 64<br></code></pre></td></tr></table></figure><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="1-关键结构"><a href="#1-关键结构" class="headerlink" title="1.关键结构"></a>1.关键结构</h2><p>跳表结点Node，其中key用于存储改结点的值，level是个指针数组，表示改结点每层指向的下一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> max_level;<br>    std::vector&lt;Node*&gt; level;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m);<br>&#125;;<br><span class="hljs-comment">// 构造函数，初始化每个节点的层数指针指向nullptr</span><br>Node::<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m) <br>    : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">max_level</span>(m)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        level.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SkipList 数据结构，这里简单实现了下查找和插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">SkipList</span>(); <br>        <span class="hljs-type">int</span> cur_max_level;<br>        <span class="hljs-type">int</span> MAX_LEVEL;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRandomLevel</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        Node* _header;<br>&#125;;<br><span class="hljs-comment">// 构造函数</span><br>SkipList::<span class="hljs-built_in">SkipList</span>() &#123;<br>    <span class="hljs-keyword">this</span>-&gt;cur_max_level = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>-&gt; MAX_LEVEL = <span class="hljs-number">10</span> ;<br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;MAX_LEVEL);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><p>在单链表中，查找某个值需要从到尾遍历链表，在跳表中类似，只不过可以从结点最少的顶层开始查起，如果找到第一个比key要大的值则往下层找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br>    Node* cur = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">//从顶层向下遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">//在当前层中比较，直到查找元素小于key</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;level[i] &amp;&amp; cur-&gt;level[i]-&gt;key &lt; key)<br>            cur = cur-&gt;level[i];<br>    &#125;<br>    <span class="hljs-comment">// 跳出循环说明已经找到相邻的节点了，拿cur指针level 0结点的值即可</span><br>    cur = cur-&gt;level[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(cur &amp;&amp; cur-&gt;key == key)&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Success find key:&quot;</span>&lt;&lt; key &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout&lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; not in cur skip list.&quot;</span>&lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h2><p>插入主要分为如下三步：</p><p> 1.查找到需要插入的位置，即需要查找插入key值前面的一个结点。在单链表中该步骤就是一个从header开始的遍历操作，在跳表中也一样，只不过要逐层查找一个插入的位置；</p><p>2.申请新的结点。找到合适的位置之后，即可为新结点申请随机层数，如果新的层数比原来的最大层数还要打，那么需要调整下update数组，让空余的层数都指向hader结点。</p><p> 3.调整指针。前面遍历找到了每一层可以插入的前结点，只需逐层插入新结点即可。</p><p>举个例子： 假设当前我们要插入元素“40”，且随机层数为4，</p><p>步骤一：找到表中比40小的最大的数，确定插入位置</p><p><img src="https://www.bloghome.com.cn/content/images/2021/04/20140909174314145.jpeg" alt="查找插入位置"></p><p>步骤二：插入高度为4的列，并维护跳跃表的结构</p><p><img src="https://www.bloghome.com.cn/content/images/2021/04/20140909174119578.jpeg" alt="更新update指针"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br><br>    Node* current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// update 是一个指针数组，数组内存放指针，指向 level指向的节点，其索引代表层</span><br>    Node* update[<span class="hljs-keyword">this</span>-&gt;MAX_LEVEL];<br><br>    <span class="hljs-comment">// 从最高层开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 只要当前节点非空，且 key 小于目标, 就会向后遍历</span><br>        <span class="hljs-keyword">while</span>(current-&gt;level[i] &amp;&amp; current-&gt;level[i]-&gt;key &lt; key) &#123;<br>            current = current-&gt;level[i];  <span class="hljs-comment">// 节点向后移动</span><br>        &#125;<br>        update[i] = current;<br>    &#125;<br>    <span class="hljs-comment">// 遍历到 level 0 说明到达最底层了，forward[0]指向的就是跳表下一个邻近节点</span><br>    current = current-&gt;level[<span class="hljs-number">0</span>];  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != current &amp;&amp; current-&gt;key == key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;key != key ) &#123;<br>        <span class="hljs-comment">// 随机生成层的高度，也即 forward[] 大小</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetRandomLevel</span>();<br>        <span class="hljs-comment">// 如果新添加的节点层高大于当前跳表层高，则需要更新 update 数组</span><br>        <span class="hljs-keyword">if</span> (random_level &gt;= <span class="hljs-keyword">this</span>-&gt;cur_max_level) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level; i &lt; random_level; i++) &#123;<br>                update[i] = <span class="hljs-keyword">this</span>-&gt;_header;<br>            &#125;<br>            <span class="hljs-keyword">this</span>-&gt;cur_max_level = random_level; <span class="hljs-comment">// 最后更新跳表层高</span><br>        &#125;<br>        <span class="hljs-comment">// 创建节点，并进行逐层插入操作</span><br>        Node* inserted_node =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, random_level);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; random_level; i++) &#123;<br>            inserted_node-&gt;level[i] = update[i]-&gt;level[i];<br>            update[i]-&gt;level[i] = inserted_node;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successfully inserted key: &quot;</span> &lt;&lt; inserted_node-&gt;key  &lt;&lt; <span class="hljs-string">&quot;random_level:&quot;</span> &lt;&lt; inserted_node-&gt;max_level &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h1><p>1.上述代码中通过随机的方式生成每个结点出现的层数，但这样有可能导致层数出现的不均衡，使得某些key查找的效率高，某些查找效率低。</p><p>为解决这一问题可以在GetRandomLevel()的时候采用轮询的方式，这样结点出现的层数会均匀分布。</p><h1 id="附完整代码"><a href="#附完整代码" class="headerlink" title="附完整代码"></a>附完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> max_level;<br>    std::vector&lt;Node*&gt; level;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m);<br>&#125;;<br><br>Node::<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m) <br>    : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">max_level</span>(m)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        level.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">SkipList</span>(); <br>        <span class="hljs-type">int</span> cur_max_level;<br>        <span class="hljs-type">int</span> MAX_LEVEL = <span class="hljs-number">10</span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRandomLevel</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        Node* _header;<br><br>&#125;;<br><br>SkipList::<span class="hljs-built_in">SkipList</span>() &#123;<br>    <span class="hljs-keyword">this</span>-&gt;cur_max_level = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;MAX_LEVEL);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::GetRandomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> level = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-keyword">this</span>-&gt;MAX_LEVEL);<br>    level = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, level);<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br>    Node* cur = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">//从顶层向下遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">//在当前层中比较，直到查找元素小于key</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;level[i] &amp;&amp; cur-&gt;level[i]-&gt;key &lt; key)<br>            cur = cur-&gt;level[i];<br>    &#125;<br>    <span class="hljs-comment">// 跳出循环说明已经找到相邻的节点了，拿cur指针level 0结点的值即可</span><br>    cur = cur-&gt;level[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(cur &amp;&amp; cur-&gt;key == key)&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Success find key:&quot;</span>&lt;&lt; key &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout&lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; not in cur skip list.&quot;</span>&lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkipList::display_list</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n******** Skip List ********&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <br>    <span class="hljs-comment">// 逐层打印</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">this</span>-&gt;cur_max_level; i++) &#123;<br>        Node *node = <span class="hljs-keyword">this</span>-&gt;_header-&gt;level[i]; <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Level &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            std::cout &lt;&lt; node-&gt;key&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt; node-&gt;max_level &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>            node = node-&gt;level[i];<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br><br>    Node* current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// update 是一个指针数组，数组内存放指针，指向 level指向的节点，其索引代表层</span><br>    Node* update[<span class="hljs-keyword">this</span>-&gt;MAX_LEVEL];<br><br>    <span class="hljs-comment">// 从最高层开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 只要当前节点非空，且 key 小于目标, 就会向后遍历</span><br>        <span class="hljs-keyword">while</span>(current-&gt;level[i] &amp;&amp; current-&gt;level[i]-&gt;key &lt; key) &#123;<br>            current = current-&gt;level[i];  <span class="hljs-comment">// 节点向后移动</span><br>        &#125;<br>        update[i] = current;<br>    &#125;<br>    <span class="hljs-comment">// 遍历到 level 0 说明到达最底层了，level[0]指向的就是跳表下一个邻近节点</span><br>    current = current-&gt;level[<span class="hljs-number">0</span>];  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != current &amp;&amp; current-&gt;key == key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;key != key ) &#123;<br>        <span class="hljs-comment">// 随机生成层的高度，也即 forward[] 大小</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetRandomLevel</span>();<br>        <span class="hljs-comment">// 如果新添加的节点层高大于当前跳表层高，则需要更新 update 数组</span><br>        <span class="hljs-keyword">if</span> (random_level &gt;= <span class="hljs-keyword">this</span>-&gt;cur_max_level) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level; i &lt; random_level; i++) &#123;<br>                update[i] = <span class="hljs-keyword">this</span>-&gt;_header;<br>            &#125;<br>            <span class="hljs-keyword">this</span>-&gt;cur_max_level = random_level; <span class="hljs-comment">// 最后更新跳表层高</span><br>        &#125;<br>        <span class="hljs-comment">// 创建节点，并进行插入操作</span><br>        Node* inserted_node =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, random_level);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; random_level; i++) &#123;<br>            inserted_node-&gt;level[i] = update[i]-&gt;level[i];<br>            update[i]-&gt;level[i] = inserted_node;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successfully inserted key: &quot;</span> &lt;&lt; inserted_node-&gt;key  &lt;&lt; <span class="hljs-string">&quot;random_level:&quot;</span> &lt;&lt; inserted_node-&gt;max_level &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;begin: &quot;</span> &lt;&lt;std::endl;<br>    SkipList skip_list;<br>    skip_list.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">1</span>);<br>    skip_list.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">2</span>);<br>    skip_list.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">3</span>);<br>    skip_list.<span class="hljs-built_in">display_list</span>();<br>    skip_list.<span class="hljs-built_in">search</span>(<span class="hljs-number">2</span>);<br>    skip_list.<span class="hljs-built_in">search</span>(<span class="hljs-number">4</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bloghome.com.cn/post/shen-du-li-jie-tiao-yue-lian-biao-yi-chong-ji-yu-gai-lu-xuan-ze-de-ping-heng-shu.html">bloghome博客之家-分享知识-放飞梦想</a></p>]]></content>
    
    
    <categories>
      
      <category>skiplist</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络探测指令</title>
    <link href="/MyBlog/2022/06/08/Linux%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E6%8C%87%E4%BB%A4/"/>
    <url>/MyBlog/2022/06/08/Linux%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>服务端日常维护中，经常需要排查网络连通性及性能，ping、telnet命令有时候不能满足需求，本文收集整理了一些有用的网络探测命令</p><h2 id="nc-端口探测"><a href="#nc-端口探测" class="headerlink" title="nc 端口探测"></a>nc 端口探测</h2><p>nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具。我们知道telnet host port 只能用于测试tcp连通性，nc的功能包括：</p><p>（1）实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口</p><p>（2）端口的扫描，nc可以作为client发起TCP或UDP连接</p><p>（3）机器之间传输文件</p><p>（4）机器之间网络测速</p><p>1.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">-g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。<br>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。<br>-h 在线帮助。<br>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。<br>-l 使用监听模式，管控传入的资料。<br>-n 直接使用IP地址，而不通过域名服务器。<br>-o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。<br>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。<br>-r 乱数指定本地与远端主机的通信端口。<br>-s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。<br>-u 使用UDP传输协议。<br>-v 显示指令执行过程。<br>-w&lt;超时秒数&gt; 设置等待连线的时间。<br>-z 使用0输入/输出模式，只在扫描通信端口时使用。<br></code></pre></td></tr></table></figure><p>2.简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -v -z -w2 192.168.0.3 1-100 <br>nc -vzw 2 192.168.0.3 1-100 <br></code></pre></td></tr></table></figure><p>该样例扫描192.168.0.3 的端口 范围是 1-100，-v用于显示执行过程，-z不会产生额外的数据包，-w后面跟2表示最大等待时间2秒</p><p>3.拷贝文件</p><p>从server1拷贝文件到server2上。需要先在server2上，用nc激活监听，如下面的命令在server2上监听1234号端口，并把收到的数据写入1234.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">server2：<br>[root@server2 ~]# nc -l 1234 &gt; 1234.txt<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">server1：<br>[root@server1 ~]# cat abc.txt <br>abc.txtabc.txtabc.txtabc.txtabc.txtabc.txtabc.txtabc.txtabc.txt<br>[root@server1 ~]# nc -w 1 192.168.200.27 1234 &lt; abc.txt<br></code></pre></td></tr></table></figure><p>server1调用nc将abc.txt写入192.168.200.27 1234号端口</p><h2 id="traceroute-路径探测"><a href="#traceroute-路径探测" class="headerlink" title="traceroute 路径探测"></a>traceroute 路径探测</h2><p>traceroute命令用于显示数据包到主机间的路径。</p><p>1.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install traceroute<br></code></pre></td></tr></table></figure><p>2.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">-d：使用Socket层级的排错功能；<br>-f&lt;存活数值&gt;：设置第一个检测数据包的存活数值TTL的大小；<br>-F：设置勿离断位；<br>-g&lt;网关&gt;：设置来源路由网关，最多可设置8个；<br>-i&lt;网络界面&gt;：使用指定的网络界面送出数据包；<br>-I：使用ICMP回应取代UDP资料信息；<br>-m&lt;存活数值&gt;：设置检测数据包的最大存活数值TTL的大小；<br>-n：直接使用IP地址而非主机名称；<br>-p&lt;通信端口&gt;：设置UDP传输协议的通信端口；<br>-r：忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-s&lt;来源地址&gt;：设置本地主机送出数据包的IP地址；<br>-t&lt;服务类型&gt;：设置检测数据包的TOS数值；<br>-v：详细显示指令的执行过程；<br>-w&lt;超时秒数&gt;：设置等待远端主机回报的时间；<br>-x：开启或关闭数据包的正确性检验。<br></code></pre></td></tr></table></figure><p>2.简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">traceroute -m 10 www.baidu.com # 跳数设置<br>traceroute -n www.baidu.com    # 显示IP地址，不查主机名<br>traceroute -p 6888 www.baidu.com  # 探测包使用的基本UDP端口设置6888<br>traceroute -q 4 www.baidu.com  # 把探测包的个数设置为值4<br>traceroute -r www.baidu.com    # 绕过正常的路由表，直接发送到网络相连的主机<br>traceroute -w 3 www.baidu.com  # 把对外发探测包的等待响应时间设置为3秒<br></code></pre></td></tr></table></figure><h2 id="mtr-路由探测"><a href="#mtr-路由探测" class="headerlink" title="mtr 路由探测"></a>mtr 路由探测</h2><p>MTR（My traceroute） 是一款强大的网络诊断工具，它集成了 <a href="https://wker.com/besttrace/">traceroute</a> 和 ping 的功能，并且会收集更多的信息，比如连接状态、可用性等等，在排查网络问题中，非常有用。</p><p>1.mrt安装</p><p>在 Linux下可以直接使用 yum 工具（以 CentOS 为例）进行安装：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">yum</span> <span class="hljs-string">provides</span> <span class="hljs-string">mtr</span>      <span class="hljs-comment">#查看mtr命令是由哪个安装包提供</span><br><span class="hljs-string">yum</span> <span class="hljs-string">install</span> <span class="hljs-string">mtr</span> <span class="hljs-string">-y</span>     <span class="hljs-comment">#安装mtr</span><br></code></pre></td></tr></table></figure><p>2.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">-F, --filename FILE        read hostname(s) from a file<br>-4                         use IPv4 only<br>-6                         use IPv6 only<br>-u, --udp                  use UDP instead of ICMP echo<br>-T, --tcp                  use TCP instead of ICMP echo<br>-a, --address ADDRESS      bind the outgoing socket to ADDRESS<br>-f, --first-ttl NUMBER     set what TTL to start<br>-m, --max-ttl NUMBER       maximum number of hops<br>-U, --max-unknown NUMBER   maximum unknown host<br>-P, --port PORT            target port number for TCP, SCTP, or UDP<br>-L, --localport LOCALPORT  source port number for UDP<br>-s, --psize PACKETSIZE     set the packet size used for probing<br>-B, --bitpattern NUMBER    set bit pattern to use in payload<br>-i, --interval SECONDS     ICMP echo request interval<br>-G, --gracetime SECONDS    number of seconds to wait for responses<br>-Q, --tos NUMBER           type of service field in IP header<br>-e, --mpls                 display information from ICMP extensions<br>-Z, --timeout SECONDS      seconds to keep probe sockets open<br>-r, --report               output using report mode<br>-w, --report-wide          output wide report<br>-c, --report-cycles COUNT  set the number of pings sent<br>-j, --json                 output json<br>-x, --xml                  output xml<br>-C, --csv                  output comma separated values<br>-l, --raw                  output raw format<br>-p, --split                split output<br>-t, --curses               use curses terminal interface<br>    --displaymode MODE     select initial display mode<br>-n, --no-dns               do not resove host names<br>-b, --show-ips             show IP numbers and host names<br>-o, --order FIELDS         select output fields<br>-y, --ipinfo NUMBER        select IP information in output<br>-z, --aslookup             display AS number<br>-h, --help                 display this help and exit<br>-v, --version              output version information and exit<br></code></pre></td></tr></table></figure><p>3.简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用-r参数显示报告,默认是动态显示的：<br>mtr -r www.badu.com<br><br>使用-c参数设置每秒发送数据包数量:<br>mtr -r -c 30 www.baidu.com<br><br>使用-s参数指定ping数据包的大小：<br>mtr -r -c 30 -s 1024 www.baidu.com<br></code></pre></td></tr></table></figure><h2 id="wrk-性能探测"><a href="#wrk-性能探测" class="headerlink" title="wrk 性能探测"></a>wrk 性能探测</h2><p>wrk是一款针对HTTP协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I&#x2F;O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。</p><p>1.linux环境安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install build-essential libssl-dev git -y<br>git clone https://github.com/wg/wrk.git wrk<br>cd wrk<br>make<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将可执行文件移动到 /usr/local/bin 位置</span><br>sudo cp wrk /usr/local/bin<br></code></pre></td></tr></table></figure><p>2.使用简介</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wrk -t12 -c400 -d30s http://www.baidu.com<br></code></pre></td></tr></table></figure><p>这条命令表示，利用 wrk 对 <a href="http://www.baidu.com/">www.baidu.com</a> 发起压力测试，线程数为 12，模拟 400 个并发请求，持续 30 秒。</p><p>3.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            <br>  Options:                                            <br>    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  <br>    -d, --duration    &lt;T&gt;  压测时间           <br>    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   <br><br>    -s, --script      &lt;S&gt;  指定Lua脚本路径       <br>    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      <br>        --latency          在压测结束后，打印延迟统计信息   <br>        --timeout     &lt;T&gt;  超时时间     <br>    -v, --version          打印正在使用的wrk的详细版本信息<br><br>  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)<br>  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/AePNULaXl8sZlIQTTJz2TA">Linux 网络延迟排查方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kcp学习笔记</title>
    <link href="/MyBlog/2022/05/30/kcp%E7%AE%80%E4%BB%8B/"/>
    <url>/MyBlog/2022/05/30/kcp%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="KCP学习笔记"><a href="#KCP学习笔记" class="headerlink" title="KCP学习笔记"></a>KCP学习笔记</h1><p> 网络游戏中通常采用UDP协议来避免TCP拥塞算法的限制，几种常见的UDP开源方案有：QUIC、ENET、KCP、UDT</p><h1 id="kcp-x2F-quic-x2F-enet-x2F-UDT协议的区别"><a href="#kcp-x2F-quic-x2F-enet-x2F-UDT协议的区别" class="headerlink" title="kcp&#x2F;quic&#x2F;enet&#x2F;UDT协议的区别"></a>kcp&#x2F;quic&#x2F;enet&#x2F;UDT协议的区别</h1><ul><li><strong>quic 是一个完整固化的 http 应用层协议</strong>，目前已经更名 http&#x2F;3，指定使用 udp（虽然本质上并不一定需要 udp）。其主要目的是为了整合TCP协议的可靠性和udp协议的速度和效率，其主要特性包括：避免前序包阻塞、减少数据包、向前纠错、会话重启和并行下载等，然而QUIC对标的是TCP+TLS+SPDY，相比其他方案更重，目前国内用于网络游戏较少</li><li><strong>kcp 只是一套基于无连接的数据报文之上的连接和拥塞控制协议</strong>，对底层【无连接的数据报文】没有具体的限制，可以基于 udp，也可以基于伪造的 tcp&#x2F;icmp 等，也可以基于某些特殊环境的非 internet 网络（比如各种现场通信总线）</li><li><strong>enet</strong>: 有ARQ协议。收发不用自己实现，提供连接管理，心跳机制。支持人数固定。自己实现跨平台。支持可靠无序通道。没有拥塞控制。线程不安全</li><li><strong>UDT</strong>建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的<a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&spm=1001.2101.3001.7020">应用层</a>协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。UDT的主要目的是支持高速<a href="https://so.csdn.net/so/search?q=%E5%B9%BF%E5%9F%9F%E7%BD%91&spm=1001.2101.3001.7020">广域网</a>上的海量数据传输。</li></ul><h1 id="kcp基本原理"><a href="#kcp基本原理" class="headerlink" title="kcp基本原理"></a>kcp基本原理</h1><p>KCP以牺牲网络公平性来追求更低的延时，适合游戏一类对延迟敏感的独占式应用。 KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低为三分之一的传输效果。</p><p>纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP</p><h2 id="1-KCP的优势："><a href="#1-KCP的优势：" class="headerlink" title="1.KCP的优势："></a>1.KCP的优势：</h2><p>1）RTO x 2 vs RTO x 1.5 ： 超时增长更平缓, 更快重发。<br> 2）全部重传 vs 选择性重传 ： TCP丢包时全部重传自丢包开始的所有数据包，KCP只重传真正丢失的数据包。（<br> 3）快速重传：当某个包被跳过的此时超过一定阈值时， 直接重传<br> 4）延迟ACK vs 非延迟ACK：TCP为了充分利用带宽，延迟发送ACK。 RTT(Round Trip Time)时间增大，计算出更大的RTO。KCP的ACK是否延迟发送可以调节。</p><p>5）UNA vs ACK+UNA： ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</p><p>6）非退让流控： KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取流畅传输的效果。</p><h2 id="2-KCP数据包"><a href="#2-KCP数据包" class="headerlink" title="2.KCP数据包"></a>2.KCP数据包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPSEG</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">node</span>;</span> <span class="hljs-comment">//报文前后向指针</span><br> IUINT32 conv, <span class="hljs-comment">//会话编号，通信双方必须一致</span><br> IUINT32 cmd, <span class="hljs-comment">//当前报文的类型：IKCP_CMD_PUSH、IKCP_CMD_ACK、ICKP_CMD_WASK、ICKP_CMD_WINS</span><br> IUINT32 frg, <span class="hljs-comment">//分片编号,倒序</span><br> IUINT32 wnd, <span class="hljs-comment">//当前可用窗口大小</span><br> IUINT32 ts, <span class="hljs-comment">//发送时间戳</span><br> IUINT32 sn, <span class="hljs-comment">//报文编号或者确认报文编号</span><br> IUINT32 una, <span class="hljs-comment">//当前未确认的数据包的编号，此编号前的所有报文已经确认</span><br> IUINT32 len, <span class="hljs-comment">//报文数据长度</span><br> IUINT32 resendts, <span class="hljs-comment">//下一次重发该报文的时间</span><br> IUINT32 rto, <span class="hljs-comment">//重传超时</span><br> IUINT32 fastack, <span class="hljs-comment">//收到ACK时被跳过几次，用于快速重传</span><br> IUINT32 xmit, <span class="hljs-comment">//记录该报文被重传了几次</span><br> <span class="hljs-type">char</span> data[<span class="hljs-number">1</span>], <span class="hljs-comment">//数据部分</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-KCP发送模式："><a href="#3-KCP发送模式：" class="headerlink" title="3.KCP发送模式："></a>3.KCP发送模式：</h2><p>流模式 kcp-&gt;stream!&#x3D;0<br>包模式 kcp-&gt;streaam&#x3D;&#x3D;0</p><h2 id="4-KCP发送包的流程"><a href="#4-KCP发送包的流程" class="headerlink" title="4.KCP发送包的流程"></a>4.KCP发送包的流程</h2><p>1）上层应用可以调用 ikcp_send 来发送数据。ikcpcb 中定义了发送相关的缓冲队列和 buf，分别是 snd_queue 和 snd_buf。应用层调用 ikcp_send 后，数据将会进入到 snd_queue 中，而下层函数 ikcp_flush 将会决定将多少数据从 snd_queue 中移到 snd_buf 中，进行发送。<br> 2）若选择流模式，则需要填充snd_queue中最后一个包的空余部分，否则直接安装数据大小封装成若干个kcp_segments放入snd_queue,流模式的分片号frg&#x3D;0,包模式分片递减<br> 3）update的时候会执行ikcp_flush，根据本次发送可用窗口的大小将snd_queue中的数据放到snd_buf中<br> 4）flush的数据报文的时候进行首次发送、超时重传、快速重传、拥塞控制等流量控制</p><h2 id="5-KCP接收数据包"><a href="#5-KCP接收数据包" class="headerlink" title="5.KCP接收数据包"></a>5.KCP接收数据包</h2><p>1)kcp_input输入UDP收到的数据包，并解析出kcp包头;</p><p>2)根据una删除掉snd_buf里所有una之前的kcp数据包；<br>3)根据wnd字段更新接收端的窗口大小;</p><p>4)根据cmd字段分别处理不同格式的包：ACK、CMD_PUSH、CMD_WASK</p><p>5)对于CMD_PUSH格式的数据包，解包放入rcv_buffer中，同时KCP会把收到的数据包的sn、ts放置到acklist中，update时会读取acklist，从而以IKCP_CMD_ACK的命令返回确认包。</p><h2 id="6-接收处理流程"><a href="#6-接收处理流程" class="headerlink" title="6.接收处理流程"></a>6.接收处理流程</h2><p>1）对于IKCP_CMD_PUSH的数据包：KCP会把收到的数据包的sn、ts放置到acklist中，update时会读取acklist，并以IKCP_CMD_ACK的命令返回确认包。<br> 2）在rcv_buf队列中丢弃掉接收窗口之外的和重复的包，将有效数据包移动到rcv_queue,rcv_buf中的数据可能是间隔的，但是rcv_queue中的数据是连续的</p><p>3)对于IKCP_CMD_ACK数据确认包<br>两个使命：1、RTO更新，2、确认发送包接收方已接收到</p><h1 id="kcp数据发送过程"><a href="#kcp数据发送过程" class="headerlink" title="kcp数据发送过程"></a>kcp数据发送过程</h1><p>用户发送数据的函数为ikcp_send。 ikcp_send(ikcpcb kcp, const char buffer, int len)<br>该函数的功能非常简单，把用户发送的数据根据MSS进行分片。如用户发送1900字节的数据，MTU为1400byte。因此，该函数会把1900byte的用户数据分成两个包，一个数据大小为1400，头frg设置为1，len设置为1400；第二个包，头frg设置为0，len设置为500。切好KCP包之后，放入到名为snd_queue的待发送队列中。</p><p>注：流模式情况下，kcp会把两次发送的数据衔接为一个完整的kcp包。非流模式下，用户数据%MSS的包，也会作为一个包发送出去。</p><p>KCP会不停的进行update更新最新情况，数据的实际发送在update时进行。发送过程如下图所示：</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_2d31d4129d488b1f0311b389f0381aeb.png"></p><p><strong>步骤1：待发送队列移至发送队列</strong><br>KCP会把snd_queue待发送队列中的kcp包，移至snd_buf发送队列。移动的包的数量不会超过snd_una+cwnd-snd_nxt，确保发送的数据不会让接收方的接收队列溢出。该功能类似于TCP协议中的滑动窗口。cwnd&#x3D;min(snd_wnd,rmt_wnd,kcp-&gt;cwnd)的最小值决定，snd_wnd，rmt_wnd比较好理解可发送的数据，可发送的数据最大值，应该是发送方可以发送的数据和接收方可以接收的数据的最小值。kcp-&gt;cwnd是拥塞控制的一个值，跟网络状况相关，网络状况差的时候，KCP认为应该降低发送的数据，后面会有详细的介绍。<br>如上图中，snd_queue待发送队列中有4个KCP包等待发送，这个时候snd_nxt下一个发送的kcp包序列号为11，snd_una下一个确认的KCP包为9（8已经确认，9，10已经发送但是还没得到接收方的确认）。因为cwnd&#x3D;5，发送队列中还有2个发送了但是还未得到确认，所以可以从待发送队列中取前面的3个KCP包放入到发送队列中，序列号分别设置为11,12,13。</p><p><strong>步骤2：发送发送队列的数据</strong><br>发送队列中包含两种类型的数据，已发送但是尚未被接收方确认的数据，没被发送过的数据。没发送过的数据比较好处理，直接发送即可。重点在于已经发送了但是还没被接收方确认的数据，该部分的策略直接决定着协议快速、高效与否。KCP主要使用两种策略来决定是否需要重传KCP数据包，<strong>超时重传、快速重传、选择重传。</strong></p><p><strong>1、超时重传</strong><br>TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，而KCP非快速模式下每次+RTO，急速模式下+0.5RTO（实验证明1.5这个值相对比较好），<strong>提高了传输速度。</strong></p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_56527e74be21a25ff46f616227f2abcd.jpg"></p><p><strong>2、快速重传</strong><br>发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。<u>TCP也有快速重传算法，TCP包被跳过3次之后会进行重传。</u><br>注：可以通过统计错误重传（重传的包实际没丢，仅乱序），优化该设置。</p><p><strong>3、选择重传</strong><br>老的TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。但是，目前大部分的操作系统，linux与android手机均是支持SACK选择重传的。</p><p><strong>步骤3：数据发送</strong><br>通过步骤2判定，kcp包是否需要发送，如果需要发送的kcp包则通过，kcp_setoutput设置的发送接口进行发送，UDP通常为sendto。步骤3，会对较小的kcp包进行合并，一次性发送提高效率</p><h1 id="kcp数据接收过程"><a href="#kcp数据接收过程" class="headerlink" title="kcp数据接收过程"></a>kcp数据接收过程</h1><p>KCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。</p><p><strong>2.3.1 KCP数据包接收</strong></p><p>kcp_input输入UDP收到的数据包。kcp包对前面的24个字节进行解压，包括conv、 frg、 cmd、 wnd、 ts、 sn、 una、 len。根据una，会删除snd_buf中，所有una之前的kcp数据包，因为这些数据包接收者已经确认。根据wnd更新接收端接收窗口大小。根据不同的命令字进行分别处理。数据接收后，更新流程如下所示：</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_3256d4c1f19d4445432fb9ade84eea1d.png"></p><p><strong>1、IKCP_CMD_PUSH数据发送命令</strong><br>a、KCP会把收到的数据包的sn及ts放置在acklist中，两个相邻的节点为一组，分别存储sn和ts。<strong>update时会读取acklist，并以IKCP_CMD_ACK的命令返回确认包</strong>。如下图中，收到了两个kpc包，acklist中会分别存放10,123,11,124。<br>b、kcp数据包放置rcv_buf队列。丢弃接收窗口之外的和重复的包。然后将rcv_buf中的包，移至rcv_queue。原来的rcv_buf中已经有sn&#x3D;10和sn&#x3D;13的包了，sn&#x3D;10的kcp包已经在rcv_buf中了，因此新收到的包会直接丢弃掉，sn&#x3D;11的包放置至rcv_buf中。<br>c、把rcv_buf中前面连续的数据sn&#x3D;11，12，13全部移动至rcv_queue，rcv_nxt也变成14。</p><p><strong>rcv_queue的数据是连续的，rcv_buf可能是间隔的</strong><br>d、kcp_recv函数，用户获取接收到数据（去除kcp头的用户数据）。该函数根据frg，把kcp包数据进行组合返回给用户。</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_44e1f9fd5a655f657ac3a1c913697ad9.png"></p><p><strong>2、IKCP_CMD_ACK数据确认包</strong><br>两个使命：1、RTO更新，2、确认发送包接收方已接收到。</p><p><strong>正常情况：</strong>收到的sn为11,una为12。表示sn为11的已经确认，下一个等待接收的为12。发送队列中，待确认的一个包为11，这个时候snd_una向后移动一位，序列号为11的包从发送队列中删除。</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_4f16b7ccbb3e0285c87dd9ca88a2f605.png"></p><p>[ 数据确认包处理流程 ]</p><p><strong>异常情况：</strong>如下图所示，sn!&#x3D;11的情况均为异常情况。sn&lt;11表示，收到重复确认的包，如本来以为丢失的包重新又收到了，所以产生重复确认的包；sn&gt;17，收到没发送过的序列号，概率极低，可能是conv没变重启程序导致的；112，则启动快速重传</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_b08898c35b63d9e02a8b4a229df8b0e4.png"></p><p><em>确认包发送，接收到的包会全部放在acklist中，以IKCP_CMD_ACK包发送出去</em></p><h1 id="KCP使用接口"><a href="#KCP使用接口" class="headerlink" title="KCP使用接口"></a>KCP使用接口</h1><h2 id="1-创建-KCP对象"><a href="#1-创建-KCP对象" class="headerlink" title="1.创建 KCP对象"></a>1.创建 KCP对象</h2><p>初始化 kcp对象，conv为一个表示会话编号的整数，和tcp的 conv一样，通信双</p><p>方需保证 conv相同，相互的数据包才能够被认可，user是一个给回调函数的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ikcpcb *kcp = ikcp_create(conv, user);<br></code></pre></td></tr></table></figure><h2 id="2-设置传输回调函数（如UDP的send函数）"><a href="#2-设置传输回调函数（如UDP的send函数）" class="headerlink" title="2.设置传输回调函数（如UDP的send函数）"></a>2.设置传输回调函数（如UDP的send函数）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// KCP的下层协议输出函数，KCP需要发送数据时会调用它</span><br><br><span class="hljs-comment">// buf/len 表示缓存和长度</span><br><br><span class="hljs-comment">// user指针为 kcp对象创建时传入的值，用于区别多个 KCP对象</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">udp_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, ikcpcb *kcp, <span class="hljs-type">void</span> *user)</span><br><br>&#123;<br> .... <br>&#125;<br><br><span class="hljs-comment">// 设置回调函数</span><br><br>kcp-&gt;output = udp_output;<br></code></pre></td></tr></table></figure><h2 id="3-循环调用-update"><a href="#3-循环调用-update" class="headerlink" title="3. 循环调用 update"></a>3. 循环调用 update</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 以一定频率调用 ikcp_update来更新 kcp状态，并且传入当前时钟（毫秒单位）</span><br><br><span class="hljs-comment">// 如 10ms调用一次，或用 ikcp_check确定下次调用 update的时间不必每次调用</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-输入一个应用层数据包（如UDP收到的数据包）"><a href="#4-输入一个应用层数据包（如UDP收到的数据包）" class="headerlink" title="4. 输入一个应用层数据包（如UDP收到的数据包）"></a>4. 输入一个应用层数据包（如UDP收到的数据包）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 收到一个下层数据包（比如UDP包）时需要调用：</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_input</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">long</span> size)</span>;<br></code></pre></td></tr></table></figure><h2 id="5-发送数据包"><a href="#5-发送数据包" class="headerlink" title="5.发送数据包"></a>5.发送数据包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// flush 发送缓冲区, 会在 ikcp_update 中调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_flush</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br></code></pre></td></tr></table></figure><h1 id="相关扩展"><a href="#相关扩展" class="headerlink" title="相关扩展"></a>相关扩展</h1><h2 id="Jacobson-x2F-Karn算法"><a href="#Jacobson-x2F-Karn算法" class="headerlink" title="Jacobson&#x2F;Karn算法"></a>Jacobson&#x2F;Karn算法</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">为保持数据传输的高效性，TCP中维持了一个超时重传时间间隔：RTO, 时间间隔太短可能导致大量不必要的重传，太长则导致性能下降；因此TCP和KCP均采用了一个高度动态的算法：Jacobson算法，来不断的调整超时重传的RTO<br>    RTO = RTT + <span class="hljs-number">4</span>D    <br>其中RTT是对往返时间的当前最佳估计值，D是平滑的平均偏差<br>    RTT = aRTT + (<span class="hljs-number">1</span>-<span class="hljs-keyword">a</span>)M<br>其中M是自数据包发送到被确认所花费的时间，<span class="hljs-keyword">a</span>是平滑因子，经典值是 <span class="hljs-number">7</span>/<span class="hljs-number">8</span>,及旧的RTT占比重的<span class="hljs-number">7</span>/<span class="hljs-number">8</span>的权重，新测量的往返时间占<span class="hljs-number">1</span>/<span class="hljs-number">8</span><br>    D = aD + (<span class="hljs-number">1</span>-<span class="hljs-keyword">a</span>)|RTT-M|<br>Jacobson 算法只用于处理正常的情况，但是当发生重传后，如果收到一个确认，这时候就不用这个算法来调整 RTO 值了。因为你无法判断这个确认是针对第一次传输，还是后来的重传。在这种情况下，采用 Karn 算法来调整 RTO 的值 。<br>Karn 算法很简单：<br><span class="hljs-number">1</span>）、 对于发生重传的数据段，在收到确认后，不更新 RTT<br><span class="hljs-number">2</span>）、在重传的时候，RTO 是倍增的，直到达到最大值的限制。如果重传超过一定的次数，TCP 连接会断开<br><span class="hljs-number">3</span>）、在重传并收到确认后，如果下一次的数据段没有发生重传（即一次性收到确认），则又恢复 Jacobson 算法<br></code></pre></td></tr></table></figure><h2 id="曾经遇到的一个面试题"><a href="#曾经遇到的一个面试题" class="headerlink" title="曾经遇到的一个面试题"></a>曾经遇到的一个面试题</h2><p>问题：对于一个采用UDP传输协议的网络，假如第一个包的1号分片和第二个包的1号分片同时到达，而接收队列只能缓存1个包（1024个分片），应该怎样处理？<br> 答：问题描述中，1号分片和1025号分片同时到达，接收队列只能缓存1024个分片，若只有一个缓存队列且无法队列无法扩展，那么只有在队列满的时候丢弃掉1025号，然后前1024号分片从缓存队列移除后重传1025，但是通过KCP的两级队列可以有效解决这一问题：1号和1025号同时缓存在rev_buffer中，等2号、3号等分片到来时，连续分片（1&#x2F;2&#x2F;3）会被移动到rev_queue,从而保证rev_buffer不会超过1024的容量，若先到的不是2号分片，则在2号被跳过3次后认为2号丢失，会立即重传。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://disenone.github.io/2019/12/17/kcp">KCP 源码剖析 - Disenone</a></p><p><a href="https://wetest.qq.com/lab/view/391.html?=content_qcloud">专栏 - 腾讯WeTest，您的质量守护专家</a></p><p><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP 协议的原理和实现 - Luyu Huang’s Tech Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
      <category>kcp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flask框架使用</title>
    <link href="/MyBlog/2022/05/30/flask%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/MyBlog/2022/05/30/flask%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="利用flask快速创建http服务"><a href="#利用flask快速创建http服务" class="headerlink" title="利用flask快速创建http服务"></a>利用flask快速创建http服务</h1><p>Flask 是一个微型的 <a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Python">Python</a> 开发的 Web 框架，基于<a href="https://www.oschina.net/p/werkzeug">Werkzeug</a> WSGI工具箱和<a href="https://www.oschina.net/p/jinja">Jinja2</a> 模板引擎。现在我想用它来做一个web通信服务框架。</p><h2 id="安装flask"><a href="#安装flask" class="headerlink" title="安装flask"></a>安装flask</h2><p> <code>pip install flask</code></p><h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment">#coding=utf-8</span><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">import</span> json<br><br>app = Flask(__name__)<br>app.debug = <span class="hljs-literal">True</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/http/query/&#x27;</span>, methods=[<span class="hljs-string">&#x27;post&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">post_http</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.data:  <span class="hljs-comment"># 检测是否有数据</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;fail&#x27;</span>)<br>    params = request.data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-comment"># 获取到POST过来的数据，因为我这里传过来的数据需要转换一下编码。根据具体情况而定</span><br>    prams = json.loads(params)<br>    <span class="hljs-built_in">print</span>(prams)<br>    <span class="hljs-comment"># 把区获取到的数据转为JSON格式。</span><br>    <span class="hljs-keyword">return</span> jsonify(prams)<br>    <span class="hljs-comment"># 返回JSON数据。</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods = [<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;POST&quot;</span>]</span>)   </span><span class="hljs-comment"># GET 和 POST 都可以</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>():<br>    name = request.args.get(<span class="hljs-string">&quot;name&quot;</span>)<br>    age = request.args.get(<span class="hljs-string">&quot;age&quot;</span>)<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;hello&#x27;</span>, name, age<br>    res = <span class="hljs-string">&#x27;hello:%s&#x27;</span>%name<br>    check_result_info = &#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>&#125;<br>    check_result_info.update(&#123;<span class="hljs-string">&#x27;res&#x27;</span>: res&#125;)<br>    <span class="hljs-keyword">return</span> jsonify(check_result_info)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端post.py：<br>新启一个终端运行 sudo python3 post.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-#请求htp/query/接口</span><br><span class="hljs-keyword">import</span> requests, json<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> time<br>data = &#123;<br>    <span class="hljs-string">&quot;datatime&quot;</span>: <span class="hljs-string">&quot;2020-07-02&quot;</span><br>&#125;<br><span class="hljs-comment"># 这里地址要和上面的服务端地址及端口好一致</span><br>url = <span class="hljs-string">&#x27;http://127.0.0.1:5000/http/query/&#x27;</span><br><br><span class="hljs-comment"># r = requests.post(url, data=json.dumps(data))</span><br><span class="hljs-comment"># print(r.json())</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    now_time = datetime.datetime.now().strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<span class="hljs-comment"># 打印当前时间</span><br>    data[<span class="hljs-string">&quot;datatime&quot;</span>] = now_time<br>    r = requests.post(url, data=json.dumps(data)) <span class="hljs-comment"># 发送到服务端</span><br>    time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb实践</title>
    <link href="/MyBlog/2022/05/30/mongodb/"/>
    <url>/MyBlog/2022/05/30/mongodb/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>mongod</strong> 是 MongoDB 系统的主要后台进程。它处理数据请求，管理数据访问，执行后台管理操作。</p><p><strong>mongos</strong> 就是 “MongoDB Shard” 的简写，它是一个针对MongoDB分片配置的路由服务，该服务处理来自应用层的查询请求，确定数据在分片集群中的位置，以完成这些操作。从应用的角度来看，一个<strong>mongos</strong>实例表现得跟任何其他MongoDB实例完全相同</p><p><strong>shard</strong>:分片，是指将数据库拆分，将其分散在不同的机器上的过程，将数据分散到不同机器上不需要功能强大的服务器就可以存储更多的数据和处理更大的负载。其基本思想是将集合切成小块，这些小块分散到若干片里，并通过一个均衡器来对各个分片进行均衡及数据迁移。</p><p><strong>config server</strong> 配置服务器，用于存储所有的数据元信息（路由、分片）的配置。mongos本身没有物理存储分片服务器和数据路由信息，只缓存在内存里，配置服务器则实际存储这些数据，mongos第一次启动或者关掉重启就会从config server中加载配置信息，以及config server信息变化时会通知所有的mongos更新自己的状态。</p><p><strong>replica set</strong>： 副本集，其实就是shard的备份，防止shard挂掉之后数据丢失。复制提供了数据的冗余备份，并在多个服务器上存储数据副本。提供了数据的可用性并可保证数据的安全性。<br><strong>arbiter</strong>:仲裁者，是复制集中的一个mongodb实例，它并不保存数据。</p><p>总结：mongodb中，应用请求mongos来操作数据库进行增删改查，config server中存储数据库元信息，并和mongos同步，数据最终存储在shard上，为防止数据丢失同步在副本集中存储了一份。仲裁在数据存储到分片时觉得存储到哪个节点。</p><h1 id="mongodb数据访问过程"><a href="#mongodb数据访问过程" class="headerlink" title="mongodb数据访问过程"></a>mongodb数据访问过程</h1><p>MongoDB是个主从架构的数据库（开发中通常使用分片+副本集），以BSON文档的形式存数据库，额外加了些自己的东西，并以二进制编码存储。存储形式是双向链表。</p><p>MongoDB中配置有一个主节点(Primary)，多个从节点(Secondary)，并彼此之间维持心跳，当主节点挂掉后，则发生[选举](<a href="https://mongoing.com/archives/295">MongoDB的选举过程 | MongoDB中文社区</a>)，其中一个从节点变成</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/replication.png" alt="MongoDB复制结构图"></p><p>mongos 是 MongoDB 分片集群的访问入口，mongos 收到 Client 访问请求，会根据从 Config Server 获取的路由表将请求转发到后端对应的 Shard 上（通常根据_id做hash）。这里不得不说的一个容易踩坑点：通常采用Updata或者findAndModify对分片数据进行更新操作时，如果没有带分片键（_id）则会操作失败，具体原因可以看：<a href="https://blog.wolfogre.com/posts/trap-of-update-on-sharding-mongodb/">在分片的 MongoDB Collection 上做更新操作时需要注意的问题 | Wolfogre&#39;s Blog</a> （通常为了节省资源，开发环境不会对collection配置分片，导致开发环境没问题，线上update就出错，别问我为什么知道，都是血的教训）</p><h1 id="mongos连接池"><a href="#mongos连接池" class="headerlink" title="mongos连接池"></a>mongos连接池</h1><p>mongo 分片架构中，mongos 作为 mongo 分片架构的路由选择器，使用中可能比较困惑的一个问题是 ： 客户端到 mongos 和 mongos 到 mongod 的连接数是什么样的关系？是 1: 1 的关系吗？ mongos 的连接池管理策略又是怎样的？</p><p>mongos和mongod都有各自能承受的组大连接数。通常mongos和mongod的最大连接数默认值是08*ulimit -n 约为65536。 默认情况下 mongos 对客户端连接都是【 每连接每线程 】的模型，每个线程分配 1 M 的内存。mongos 内部有两种类型的连接池：传统的连接池( DBConnectionPool 结构) 和 ASIO 的连接池 ( ConnectionPool 结构)。传统连接池内的连接执行命令不会创建新的线程，是在 mongos 接收的连接创建的线程上执行的，所以不会消耗额外的内存空间。具体可参考：<a href="https://mongoing.com/archives/30014">深度剖析mongos连接池 | MongoDB中文社区</a></p><p>在实际业务中，要注意启服时大量玩家查询操作触发连接超过连接池及线程上限的情况。</p><h1 id="mongodb分片详解"><a href="#mongodb分片详解" class="headerlink" title="mongodb分片详解"></a>mongodb分片详解</h1><p>Mongo分片集群中每个数据库都有自己的 primary shard, 未分片的集合存储在 primary shard 上，已分片的集合根据 shardKey 切割成不同的 chunk 分布到多个分片上。Mongo中最常见的分片方式有两种：范围分片和hash 分片</p><h2 id="1-范围分片（Range-based-sharding）"><a href="#1-范围分片（Range-based-sharding）" class="headerlink" title="1.范围分片（Range based sharding）"></a>1.范围分片（Range based sharding）</h2><p>范围分片以shard key所属范围区间为依据对集合进行划分，根据字段的范围不同将一个集合的数据存储在不同的分片中。其原理如图</p><p><img src="/MyBlog/images/5f3f2bab6158bc7847e47cefxLlriGD101.png"></p><p>范围分片适合满足在一定范围内的查找，例如查找X的值在【100-200】之间的数据，mongo 路由根据Config server中存储的元数据，可以直接定位到指定的shard的Chunk中，但是如果shardkey有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力。</p><h2 id="2-Hash分片（Hash-based-sharding）"><a href="#2-Hash分片（Hash-based-sharding）" class="headerlink" title="2.Hash分片（Hash based sharding）"></a>2.Hash分片（Hash based sharding）</h2><p> Hash分片是根据shard key计算hash值，并根据hash值按照范围分片的策略将文档分布到不同chunk上的过程。其原理如图:</p><p><img src="/MyBlog/images/5f3f2bd02dcade25208581b3t0bFhCRS01.png"></p><p>Hash分片能将文档随机分散到各个chunk上，充分的扩展写能力，弥补了范围分片的不足，但是Hash分片不能高效的服务范围查询，所有的范围查询都要分发到后端所有的Shard才能找出满足条件的文档。</p><h1 id="生产过程中遇到的问题"><a href="#生产过程中遇到的问题" class="headerlink" title="生产过程中遇到的问题"></a>生产过程中遇到的问题</h1><p>这里记录下在线上环境中使用mongo3.4踩过的坑，注意mongo版本不同可能有所区别，但如果你碰巧遇到了同样的表现，也许可以帮你少走一些弯路。</p><h2 id="mongos缓存问题"><a href="#mongos缓存问题" class="headerlink" title="mongos缓存问题"></a>mongos缓存问题</h2><p>表现：线上某玩家自己查看自己的数据表现正常，部分其他玩家查看该玩家的数据发现是空的。自己查看和别人查看代码上唯一的区别是：自己查看走的primary，别人查看走secondary。</p><p>排查过程：登录mongoshell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongo3.4.xx -host 127.0.0.1 -port xxx -uxxx -pxxx db_name<br></code></pre></td></tr></table></figure><p>采用secondary查询，发现确实没有数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(&#123;&#x27;_id&#x27;:&#x27;111&#x27;&#125;).readPref(&quot;secondary&quot;)<br></code></pre></td></tr></table></figure><p>采用primary查询，发现有数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(&#123;&#x27;_id&#x27;:&#x27;111&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>然后再次采用secondary查询发现居然有数据了。初步猜测是mongos路由缓存问题，去其他没有执行过primary查询的机器上强制刷新路由：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.adminCommand(&quot;flushRouterConfig&quot;)<br></code></pre></td></tr></table></figure><p>然后直接采用secondary查询发现好了。</p><p>原因是：mongos充当了mongodb的路由器，路由信息来自于config server，为了减少config server的开销，mongos会缓存config这些元数据。那么什么情况下会更新这些云数据呢？</p><ul><li><p>写操作的时候</p></li><li><p>从primary读取的时候</p></li><li><p>主动调用flushRouterConfig的时候</p></li></ul><p>但是正常来讲，如果config server的路由信息不改变，mongos上缓存不刷新也没问题，但是我们知道，<strong>一个chunk上的数据超过64M（默认值）之后，会分裂（split），而当集群上不同shard上的chunk数据不均衡的是偶会发生chunk迁移（migration），如果发生了迁移，路由信息就会改变，次数如果mongos的缓存没有更新就只能将请求路由到错误的shared上去，导致返回空数据。</strong></p><h2 id="分片更新问题"><a href="#分片更新问题" class="headerlink" title="分片更新问题"></a>分片更新问题</h2><p>这个上面也有提到，就是在做了shard的表上做更新操作时，要记得带分片键（一般是_id）</p><h1 id="常用命令行操作"><a href="#常用命令行操作" class="headerlink" title="常用命令行操作"></a>常用命令行操作</h1><p>命令行登录远程mongos</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mongo</span> -host <span class="hljs-number">127.0.0.1</span> -port <span class="hljs-number">333</span> -u username -p password dbname<br></code></pre></td></tr></table></figure><p>查看数据库</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> dbs<br></code></pre></td></tr></table></figure><p>创建、切换数据库</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> <span class="hljs-keyword">db</span><br></code></pre></td></tr></table></figure><p>查看所有的数据表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> collections<br></code></pre></td></tr></table></figure><p>创建表</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">db.createCollectio<span class="hljs-meta">n</span>(<span class="hljs-string">&#x27;表名&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mongo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker实践</title>
    <link href="/MyBlog/2022/05/27/docker%E5%AE%9E%E8%B7%B5/"/>
    <url>/MyBlog/2022/05/27/docker%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h1><p>docker底层的核心技术包括linux上的命名空间（Namespaces）、控制组（Control groups）、 Union文件系统和容器格式（Container format）</p><h2 id="1-docker镜像"><a href="#1-docker镜像" class="headerlink" title="1.docker镜像"></a>1.docker镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><p><strong>分层存储</strong>：因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构</p><p>分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h2 id="2-docker容器"><a href="#2-docker容器" class="headerlink" title="2.docker容器"></a>2.docker容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h2 id="3-docker仓库"><a href="#3-docker仓库" class="headerlink" title="3.docker仓库"></a>3.docker仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="/docker_practice/repository/registry">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（&#96;</p><h2 id="4-docker-in-docker"><a href="#4-docker-in-docker" class="headerlink" title="4.docker in docker"></a>4.docker in docker</h2><p>docker in docker 顾名思义就是在docker里运行docker，现在很多服务大多部署在云上，容器云是常见的服务端架构，为了业务的快速部署，docker in docker经常被应用到容器云的业务开发。</p><p><img src="https://www.chenshaowen.com/blog/images/2020/11/dind.png"></p><h1 id="Dockerfile实例"><a href="#Dockerfile实例" class="headerlink" title="Dockerfile实例"></a>Dockerfile实例</h1><p>上面提到docker采用<code>Union FS</code>文件系统，通过分层存储文件，其具体可表现在Dockerfile上，我们通过dockerfile自定义镜像时，可以在自己或者别人已经定义好的镜像基础上逐层累加，例如我们编写一个基于debian系统的带python环境的镜像：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">FROM</span> <span class="hljs-string">debian</span><br><span class="hljs-string">COPY</span> . /<span class="hljs-string">home</span><br><span class="hljs-string">CMD</span> [<span class="hljs-string">&quot;bash&quot;</span>] <br><span class="hljs-string">LABEL</span> <span class="hljs-string">maintainer</span>=<span class="hljs-string">&#x27;python_work&#x27;</span><br><span class="hljs-string">RUN</span> \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">m</span> <span class="hljs-string">update</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> <span class="hljs-string">upgrade</span>  -<span class="hljs-string">y</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">wget</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">curl</span><br><br><br><span class="hljs-string">RUN</span> <span class="hljs-string">groupadd</span> -<span class="hljs-string">r</span> <span class="hljs-string">zhouxiao</span> &amp;&amp; \<br><span class="hljs-string">useradd</span> -<span class="hljs-string">r</span> -<span class="hljs-string">d</span> <span class="hljs-string">&quot;/home/zhouxiao&quot;</span> -<span class="hljs-string">m</span> -<span class="hljs-string">s</span> <span class="hljs-string">&quot;/bin/bash&quot;</span> -<span class="hljs-string">p</span> <span class="hljs-string">&quot;zhouxiao&quot;</span> -<span class="hljs-string">g</span> <span class="hljs-string">zhouxiao</span> <span class="hljs-string">admin</span><br><br><span class="hljs-comment"># Install Python</span><br><span class="hljs-string">RUN</span> \ <br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">python</span> <span class="hljs-string">libpython2</span>.<span class="hljs-string">7</span> <span class="hljs-string">telnet</span> <span class="hljs-string">vim</span> <span class="hljs-string">procps</span> <span class="hljs-string">rsyslog</span> <span class="hljs-string">zip</span>&amp;&amp; \<br><span class="hljs-string">wget</span> <span class="hljs-string">https</span>://<span class="hljs-string">bootstrap</span>.<span class="hljs-string">pypa</span>.<span class="hljs-string">io</span>/<span class="hljs-string">pip</span>/<span class="hljs-string">2</span>.<span class="hljs-string">7</span>/<span class="hljs-built_in">get-pip.py</span> &amp;&amp; \<br><span class="hljs-string">python</span> <span class="hljs-built_in">get-pip.py</span> &amp;&amp; \<br><span class="hljs-string">curl</span> -<span class="hljs-string">sL</span> <span class="hljs-string">https</span>://<span class="hljs-string">deb</span>.<span class="hljs-string">nodesource</span>.<span class="hljs-string">com</span>/<span class="hljs-string">setup_12</span>.<span class="hljs-string">x</span> | <span class="hljs-string">bash</span> -  &amp;&amp; \<br><span class="hljs-string">apt-get</span> <span class="hljs-string">clean</span><br></code></pre></td></tr></table></figure><p>！！ 这里<code>From</code>定义了基础镜像为debian，此外<code>COPY</code>、<code>RUN</code>等每一条命令均代表一层镜像，因此尽量将指令结合成一条可节省使用到的层数。</p><p>有了Dockerfile后我们可以生成自定义镜像：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">docker <span class="hljs-keyword">build </span>-t python_test:<span class="hljs-built_in">v1</span> -f Dockerfile .<br></code></pre></td></tr></table></figure><p>这里我们生成了python_test这个镜像，接下来可以通过这个镜像创建容器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name mypython -d python_test:v1 /bin/bash</span><br></code></pre></td></tr></table></figure><h1 id="docker-容器内文件映射"><a href="#docker-容器内文件映射" class="headerlink" title="docker 容器内文件映射"></a>docker 容器内文件映射</h1><p>有时候我们不想在镜像中copy本地文件进去，因为这样会导致镜像占用文件贼大。我们可以使用<code>docker run -v</code>指令在创建Docker容器时与本地路径进行映射共享文件，例如我需要将本地的的<code>/root/code</code>路径映射到容器内的<code>/data/code</code>路径，使用如下指令，冒号前为宿主机路径，冒号后为容器路径，其中xxx为镜像完整路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -v /root/code:/data/code xxx /bin/bash<br></code></pre></td></tr></table></figure><h1 id="docker实践"><a href="#docker实践" class="headerlink" title="docker实践"></a>docker实践</h1><p>1.由于docker采用c&#x2F;s架构，所以要先启动docker服务；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">service</span> docker status <span class="hljs-comment">#查看docker服务状态</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"> service docker <span class="hljs-literal">start</span> <span class="hljs-comment">#启动docker服务</span><br></code></pre></td></tr></table></figure><p>2.由于我本地安装的是windows版本，因此可直接启动cmd输入docker连接docker服务</p><p>3.下载镜像然后可以直接通过镜像创建容器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull nginx</span><br></code></pre></td></tr></table></figure><p>3.可以根据镜像源自定义Dockerfile文件，然后docker build创建自己的镜像</p><p>4.启动镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name webserver -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx<br></code></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>5.使用 <code>docker exec</code> 命令进入容器，修改其内容。（注意该容器必须是启动状态）</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> webserver bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/MyBlog/2021/05/20/hello-world/"/>
    <url>/MyBlog/2021/05/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>本博客采用Hexo框架搭建，具体请参考<a href="https://hexo.io/docs/index.html">Hexo</a>的文档。</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
