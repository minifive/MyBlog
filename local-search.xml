<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker实践</title>
    <link href="/MyBlog/2022/05/27/docker%E5%AE%9E%E8%B7%B5/"/>
    <url>/MyBlog/2022/05/27/docker%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h1><p>docker底层的核心技术包括linux上的命名空间（Namespaces）、控制组（Control groups）、 Union文件系统和容器格式（Container format）</p><h2 id="1-docker镜像"><a href="#1-docker镜像" class="headerlink" title="1.docker镜像"></a>1.docker镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><p><strong>分层存储</strong>：因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构</p><p>分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h2 id="2-docker容器"><a href="#2-docker容器" class="headerlink" title="2.docker容器"></a>2.docker容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h2 id="3-docker仓库"><a href="#3-docker仓库" class="headerlink" title="3.docker仓库"></a>3.docker仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="/docker_practice/repository/registry">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（&#96;</p><h2 id="4-docker-in-docker"><a href="#4-docker-in-docker" class="headerlink" title="4.docker in docker"></a>4.docker in docker</h2><p>docker in docker 顾名思义就是在docker里运行docker，现在很多服务大多部署在云上，容器云是常见的服务端架构，为了业务的快速部署，docker in docker经常被应用到容器云的业务开发。</p><p><img src="https://www.chenshaowen.com/blog/images/2020/11/dind.png"></p><h1 id="Dockerfile实例"><a href="#Dockerfile实例" class="headerlink" title="Dockerfile实例"></a>Dockerfile实例</h1><p>上面提到docker采用<code>Union FS</code>文件系统，通过分层存储文件，其具体可表现在Dockerfile上，我们通过dockerfile自定义镜像时，可以在自己或者别人已经定义好的镜像基础上逐层累加，例如我们编写一个基于debian系统的带python环境的镜像：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">FROM</span> <span class="hljs-string">debian</span><br><span class="hljs-string">COPY</span> . /<span class="hljs-string">home</span><br><span class="hljs-string">CMD</span> [<span class="hljs-string">&quot;bash&quot;</span>] <br><span class="hljs-string">LABEL</span> <span class="hljs-string">maintainer</span>=<span class="hljs-string">&#x27;python_work&#x27;</span><br><span class="hljs-string">RUN</span> \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">m</span> <span class="hljs-string">update</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> <span class="hljs-string">upgrade</span>  -<span class="hljs-string">y</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">wget</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">curl</span><br><br><br><span class="hljs-string">RUN</span> <span class="hljs-string">groupadd</span> -<span class="hljs-string">r</span> <span class="hljs-string">zhouxiao</span> &amp;&amp; \<br><span class="hljs-string">useradd</span> -<span class="hljs-string">r</span> -<span class="hljs-string">d</span> <span class="hljs-string">&quot;/home/zhouxiao&quot;</span> -<span class="hljs-string">m</span> -<span class="hljs-string">s</span> <span class="hljs-string">&quot;/bin/bash&quot;</span> -<span class="hljs-string">p</span> <span class="hljs-string">&quot;zhouxiao&quot;</span> -<span class="hljs-string">g</span> <span class="hljs-string">zhouxiao</span> <span class="hljs-string">admin</span><br><br><span class="hljs-comment"># Install Python</span><br><span class="hljs-string">RUN</span> \ <br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">python</span> <span class="hljs-string">libpython2</span>.<span class="hljs-string">7</span> <span class="hljs-string">telnet</span> <span class="hljs-string">vim</span> <span class="hljs-string">procps</span> <span class="hljs-string">rsyslog</span> <span class="hljs-string">zip</span>&amp;&amp; \<br><span class="hljs-string">wget</span> <span class="hljs-string">https</span>://<span class="hljs-string">bootstrap</span>.<span class="hljs-string">pypa</span>.<span class="hljs-string">io</span>/<span class="hljs-string">pip</span>/<span class="hljs-string">2</span>.<span class="hljs-string">7</span>/<span class="hljs-built_in">get-pip.py</span> &amp;&amp; \<br><span class="hljs-string">python</span> <span class="hljs-built_in">get-pip.py</span> &amp;&amp; \<br><span class="hljs-string">curl</span> -<span class="hljs-string">sL</span> <span class="hljs-string">https</span>://<span class="hljs-string">deb</span>.<span class="hljs-string">nodesource</span>.<span class="hljs-string">com</span>/<span class="hljs-string">setup_12</span>.<span class="hljs-string">x</span> | <span class="hljs-string">bash</span> -  &amp;&amp; \<br><span class="hljs-string">apt-get</span> <span class="hljs-string">clean</span><br></code></pre></td></tr></table></figure><p>！！ 这里<code>From</code>定义了基础镜像为debian，此外<code>COPY</code>、<code>RUN</code>等每一条命令均代表一层镜像，因此尽量将指令结合成一条可节省使用到的层数。</p><p>有了Dockerfile后我们可以生成自定义镜像：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">docker <span class="hljs-keyword">build </span>-t python_test:<span class="hljs-built_in">v1</span> -f Dockerfile .<br></code></pre></td></tr></table></figure><p>这里我们生成了python_test这个镜像，接下来可以通过这个镜像创建容器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name mypython -d python_test:v1 /bin/bash</span><br></code></pre></td></tr></table></figure><h1 id="docker-容器内文件映射"><a href="#docker-容器内文件映射" class="headerlink" title="docker 容器内文件映射"></a>docker 容器内文件映射</h1><p>有时候我们不想在镜像中copy本地文件进去，因为这样会导致镜像占用文件贼大。我们可以使用<code>docker run -v</code>指令在创建Docker容器时与本地路径进行映射共享文件，例如我需要将本地的的<code>/root/code</code>路径映射到容器内的<code>/data/code</code>路径，使用如下指令，冒号前为宿主机路径，冒号后为容器路径，其中xxx为镜像完整路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -v /root/code:/data/code xxx /bin/bash<br></code></pre></td></tr></table></figure><h1 id="docker实践"><a href="#docker实践" class="headerlink" title="docker实践"></a>docker实践</h1><p>1.由于docker采用c&#x2F;s架构，所以要先启动docker服务；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">service</span> docker status <span class="hljs-comment">#查看docker服务状态</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"> service docker <span class="hljs-literal">start</span> <span class="hljs-comment">#启动docker服务</span><br></code></pre></td></tr></table></figure><p>2.由于我本地安装的是windows版本，因此可直接启动cmd输入docker连接docker服务</p><p>3.下载镜像然后可以直接通过镜像创建容器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull nginx</span><br></code></pre></td></tr></table></figure><p>3.可以根据镜像源自定义Dockerfile文件，然后docker build创建自己的镜像</p><p>4.启动镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name webserver -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx<br></code></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>5.使用 <code>docker exec</code> 命令进入容器，修改其内容。（注意该容器必须是启动状态）</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> webserver bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/MyBlog/2021/05/20/hello-world/"/>
    <url>/MyBlog/2021/05/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
