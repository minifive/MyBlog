<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ElasticSearch学习实践</title>
    <link href="/MyBlog/2022/06/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/MyBlog/2022/06/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>ElasticSearch(以下简称ES)是一个基于Lucene构建的开源，分布式，实时的搜索与分析引擎。用于全文索引、结构化数据索引、数据分析等各方面。</p><p>在应用程序中的对象，不仅仅是简单的keys和values，更多的是由更为复杂的数据结构组成的数据构成的。ES面向文档来存储对象。</p><h2 id="精确索引VS全文索引"><a href="#精确索引VS全文索引" class="headerlink" title="精确索引VS全文索引"></a>精确索引VS全文索引</h2><p>在ES中的数据可以分为两类：精确值(exact values)以及全文(full text)。精确值：例如日期类型date，若date其有两个值:2014-09-15与2014，那么这两个值不相等。又例如字符串类型foo与Foo不相等。 全文：通常是人类语言写的文本，例如一段tweet信息、email的内容等。精确值很容易被索引：一个值要么相当要么不等。 索引全文值就需要很多功夫。ES使用<strong>倒序索引</strong>来加速全文索引。</p><h2 id="倒序索引"><a href="#倒序索引" class="headerlink" title="倒序索引"></a>倒序索引</h2><p>我们传统的检索方式是通过遍历整篇文章，逐个比对找到对应的关键词位置，而倒排索引是通过分词策略，形成词和文章的关系映射表，这种<em>词典+映射表的方式就是倒排索引</em></p><p>为方便全文搜索，ES将每个文档内容按照不同的单词（terms）进行分割，然后创建一个所有terms的列表，并且记录每一个term出现的文档。</p><p>当我们根据单词去搜索文档，我们匹配到了一个term出现的所有文档，但是第一个文档中term出现的次数比第二个文档多，可以认为第一个文档比第二个文档的匹配度要好，因此可以建立简单的按照匹配次数排序的索引算法。</p><h1 id="ES查询简介"><a href="#ES查询简介" class="headerlink" title="ES查询简介"></a>ES查询简介</h1><p>为了介绍ES中一条search请求查询的步骤，我们以下面这条查询操作为例，该查询请求从所有文档中取第100条开始的10条数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">POST /my_index/my_type/_search<br>&#123;<br>    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,<br>    &quot;from&quot;: 100,<br>    &quot;size&quot;:  10<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc，fetch 阶段取出具体的 doc。</p><h2 id="Query阶段"><a href="#Query阶段" class="headerlink" title="Query阶段"></a>Query阶段</h2><p>query阶段主要是从每个shard中获取数据，然后到一个节点上进行全局排序，从而确定最终需要的文档id。</p><ol><li>Client 发送一次搜索请求，node1 接收到请求，然后node1 创建一个大小为 from + size 的优先级队列用来存结果，我们管 node1 叫 coordinating node。</li><li>coordinating node将请求广播到涉及到的 shards，每个 shard 在内部执行搜索请求，然后，将结果存到内部的大小同样为 from + size 的优先级队列里，可以把优先级队列理解为一个包含 top N 结果的列表。</li><li>每个 shard 把暂存在自身优先级队列里的数据返回给 coordinating node，coordinating node 拿到各个 shards 返回的结果后对结果进行一次合并，产生一个全局的优先级队列，存到自身的优先级队列里。</li><li>coordinating node 计算好自己的优先级队列后，query 阶段结束，进入 fetch 阶段。</li></ol><h2 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h2><p>Fetch阶段主要是根据全局排序结果，重新去各个shard上拿数据。</p><ol><li>coordinating node 得到全局排序的top N结果后，依次发送 GET 请求到相关shards。</li><li>shard 根据 doc 的 _id 取到数据详情，然后返回给 coordinating node。</li><li>coordinating node 返回数据给 Client。</li></ol><p>需要取的数据可能在不同分片，也可能在同一分片，coordinating node 使用 <code>multi-get</code> 来避免多次去同一分片取数据，从而提高性能。</p><h2 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h2><p>ES 默认采用的分页方式是 from+ size 的形式，但在某些情况下from+size的查询方式会带来严重的性能问题，例如，在一个索引中有10亿数据，分10个 shards，然后，一个搜索请求，from&#x3D;1,000,000，size&#x3D;100，这时候在 query 阶段，每个shards需要返回 1,000,100 条数据给 coordinating node，而 coordinating node 需要接收 10 * 1,000,100 条数据，这对内存、cpu、网络资源都是一个较大的消耗。</p><p>Elasticsearch 提供了scroll 方式来实现滚动遍历从而避免深度分页问题。</p><h2 id="Search-After深度分页"><a href="#Search-After深度分页" class="headerlink" title="Search After深度分页"></a>Search After深度分页</h2><p>scroll search 的方式，官方的建议不用于实时文档的查询，原因是scroll_id基于历史快照生成，实时变化的数据不会立刻反映到快照上。那么在实时情况下如果处理深度分页的问题呢？es 给出了 search_after 的方式。</p><p>search_after根据上一页的最后一条数据来确定下一页的位置，同时在分页请求的过程中，如果有索引数据的增删改查，这些变更也会实时的反映到游标上。</p><p>使用search_after需要注意的是，为了找到每一页最后一条数据，每个文档必须有一个全局唯一值，官方推荐使用 _id 作为全局唯一值；需要排序；设置from&#x3D;0；第二页查询时需要将第一页最后一条数据传进去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">POST /my_index/my_type/_search<br>&#123;<br>  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,<br>  &quot;size&quot;: 10,<br>  &quot;from&quot;: 0,<br>  &quot;search_after&quot;: [<br>    1541495312521,<br>    &quot;d0xH6GYBBtbwbQSP0j1A&quot;<br>  ],<br>  &quot;sort&quot;: [<br>    &#123;<br>      &quot;timestamp&quot;: &#123;<br>        &quot;order&quot;: &quot;desc&quot;<br>      &#125;,<br>      &quot;_id&quot;: &#123;<br>        &quot;order&quot;: &quot;desc&quot;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="python实践"><a href="#python实践" class="headerlink" title="python实践"></a>python实践</h1><p>线上服务器会将报错内容保存成ES文档，客户端可通过ES请求筛选并拉取各种报错。</p><h2 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h2><p>我是用的是python2.7，直接pip安装python库就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install elasticsearch (7.11.0)<br></code></pre></td></tr></table></figure><h2 id="创建一个到ES服务集群的连接"><a href="#创建一个到ES服务集群的连接" class="headerlink" title="创建一个到ES服务集群的连接"></a>创建一个到ES服务集群的连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> Elasticsearch, ConnectionTimeout<br><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> helpers<br><span class="hljs-keyword">from</span> elasticsearch.compat <span class="hljs-keyword">import</span> urlencode<br><span class="hljs-keyword">from</span> elasticsearch.connection <span class="hljs-keyword">import</span> RequestsHttpConnection<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthToken</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    TOKEN AUTH BASE CLASS</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, token</span>):<br>        self.headers = &#123;<br>            <span class="hljs-string">&#x27;ELK-AUTH-TOKEN&#x27;</span>: token<br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, r</span>):<br>        r.headers.update(self.headers)<br>        <span class="hljs-keyword">return</span> r<br><br>es = Elasticsearch(host=host_url, port=xxx, connection_class=RequestsHttpConnection, http_auth=AuthToken(My_token))<br></code></pre></td></tr></table></figure><h2 id="采用search拉取"><a href="#采用search拉取" class="headerlink" title="采用search拉取"></a>采用search拉取</h2><p>基于python ES api，我们可以采用es.search拉取所有满足筛选条件的文档，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过http请求拉取</span><br>page = es.search(index=my_index, body=body, scroll=<span class="hljs-string">&quot;2m&quot;</span>, size=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>上述接口在所有文档中搜索并返回最多50条数据，其中scroll&#x3D;‘2m’表示滚动查询，上下文数据缓存时间未2分钟；</p><p>search参数说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">常用参数<br>index - 索引名<br>q - 查询指定匹配 使用Lucene查询语法<br>from_ - 查询起始点  默认<span class="hljs-number">0</span><br>doc_type - 文档类型<br>size - 指定查询条数 默认<span class="hljs-number">10</span><br>field - 指定字段 逗号分隔<br>sort - 排序  字段：asc/desc<br>body - 使用Query DSL<br>scroll - 滚动查询<br></code></pre></td></tr></table></figure><p>筛选条件放到body中，具体的规则参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/query-dsl-query-string-query.html#query-string-syntax">Elasticsearch Guide [6.7] | Elastic</a></p><p>采用es.search时会返回一个当前游标id：scroll_id记录上一次查询扫描过的文档，如果下一次想要接着上一次的查询，则可以直接使用es.scroll(scroll_id&#x3D;scroll_id, scroll &#x3D;’2m’), 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">page = self.es.search(index=self.index, body=body, scroll=<span class="hljs-string">&quot;2m&quot;</span>, size=page_size)<br>scroll_id = page[<span class="hljs-string">&#x27;_scroll_id&#x27;</span>]  <span class="hljs-comment"># 获取scrollID</span><br>total = page[<span class="hljs-string">&#x27;hits&#x27;</span>][<span class="hljs-string">&#x27;total&#x27;</span>].get(<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 数据的总条数</span><br>source_info = &#123;&#125;<br><span class="hljs-comment"># 第一页也要加到数据里去</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> page[<span class="hljs-string">&quot;hits&quot;</span>][<span class="hljs-string">&quot;hits&quot;</span>]:<br>    source = i.get(<span class="hljs-string">&quot;_source&quot;</span>, &#123;&#125;)<br>    <span class="hljs-built_in">id</span> = i.get(<span class="hljs-string">&#x27;_id&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span>: source_info[<span class="hljs-built_in">id</span>] = source<br><span class="hljs-comment"># Start scrolling</span><br><span class="hljs-keyword">while</span>(total &gt; <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Scrolling...&quot;</span>, scroll_id<br>    page = self.es.scroll(scroll_id=scroll_id, scroll =<span class="hljs-string">&#x27;2m&#x27;</span>)<br>    <span class="hljs-comment"># 更新scroll——id</span><br>    scroll_id = page[<span class="hljs-string">&#x27;_scroll_id&#x27;</span>]<br>    total = <span class="hljs-built_in">len</span>(page[<span class="hljs-string">&#x27;hits&#x27;</span>][<span class="hljs-string">&#x27;hits&#x27;</span>])<br>    <span class="hljs-comment"># 把当前页加到查询结果里面去</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> page[<span class="hljs-string">&quot;hits&quot;</span>][<span class="hljs-string">&quot;hits&quot;</span>]:<br>        source = i.get(<span class="hljs-string">&quot;_source&quot;</span>, &#123;&#125;)<br>        <span class="hljs-built_in">id</span> = i.get(<span class="hljs-string">&#x27;_id&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span>: source_info[<span class="hljs-built_in">id</span>] = source<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;data_len:&#x27;</span>, <span class="hljs-built_in">len</span>(source_info)<br><span class="hljs-keyword">return</span> source_info<br></code></pre></td></tr></table></figure><h2 id="通过scan分批次拉取"><a href="#通过scan分批次拉取" class="headerlink" title="通过scan分批次拉取"></a>通过scan分批次拉取</h2><p>另外我们也可以通过helpers.scan来分批返回结果，采用scan无需手动更新scroll_id，配合yield迭代查询效果更佳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">self.es = Elasticsearch(host=self.trace_url, port=xxx, connection_class=RequestsHttpConnection, http_auth=AuthToken(self.token))<br>start_ts, end_ts = self.parse_time_args(start, end)<br>query = self.get_body(start_ts, end_ts)<br><span class="hljs-comment"># 分页拉取，每页100条, 页数等于该时间段总日志数/100 + 1</span><br>results = helpers.scan(client=self.es, query=query, scroll=<span class="hljs-string">&#x27;2m&#x27;</span>, index=self.index, size=<span class="hljs-number">100</span>)<br>ids = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">for</span> hitobj <span class="hljs-keyword">in</span> results:<br>   source = hitobj.get(<span class="hljs-string">&quot;_source&quot;</span>, &#123;&#125;)<br>   <span class="hljs-built_in">id</span> = hitobj.get(<span class="hljs-string">&#x27;_id&#x27;</span>)<br>   ids.add(<span class="hljs-built_in">id</span>)<br>   <span class="hljs-keyword">yield</span> source<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃表skiplist</title>
    <link href="/MyBlog/2022/06/10/%E8%B7%B3%E8%B7%83%E8%A1%A8skiplist/"/>
    <url>/MyBlog/2022/06/10/%E8%B7%B3%E8%B7%83%E8%A1%A8skiplist/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃表SkipList"><a href="#跳跃表SkipList" class="headerlink" title="跳跃表SkipList"></a>跳跃表SkipList</h1><p>跳跃表是一种查询效率很高的数据结构，平均查找和插入时间复杂度都是O(log n)，最常见的应用场景如排行榜，Redis中zset就是采用跳跃表实现。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>跳跃表的性能堪比红黑树，而且实现起来比红黑树简单很多。那么什么是跳跃表？理解跳跃表前我们先看一个基单链表结构。</p><p><img src="https://img-blog.csdnimg.cn/20210317082630470.png" alt="单链表结构原理"></p><p>假如我们要查询值为 13的节点，对于上面的单向链表来说，我需要从前往后遍历节点，算一下要进行 10 次查找，性能是非常差的，如何提升查询速度？我们知道即使有序的链表也是没变法进行二分查找的，除非我们把这个链表变成红黑树这样的结构，但是红黑树实现起来太过麻烦。所以，如果我把这个链表像这样处理一下呢？</p><p><img src="https://img-blog.csdnimg.cn/20210317082645182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0OTQxNDg=,size_16,color_FFFFFF,t_70" alt="两层跳跃表结构原理"></p><p>我把第一层链表中的元素，每隔2个元素就向上提取一个元素，形成第二层的链表，如上图，如果我查找元素的时候先从最上面的层级找 13 ，当找到 18的时候大于13，就退回10，往下一层找，然后就找到13了，你数一下这一次的查找次数几乎是之前的单向链表的一半，大大节省了查询时间。那如果我再往上抽取一层呢？</p><p><img src="https://img-blog.csdnimg.cn/20210317082724541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0OTQxNDg=,size_16,color_FFFFFF,t_70" alt="三层跳跃表结构原理"></p><p>按照刚才的规律，我们再向上抽取一层，这一次查找的次数是不是又变少了？其实这种数据结构就是“跳跃表”的存储结构了。其实你可以发现他的查询性能是可以媲美红黑树的，但是实现起来比红黑树简单许多。</p><h2 id="随机层数"><a href="#随机层数" class="headerlink" title="随机层数"></a>随机层数</h2><p>跳表引入了随机深度的机制，也就是一个结点能够出现的层数数量是随机的。并且所有的跳表结点都出现在第一层中，当某结点出现在第i层，那么它一定出现在第i-1层，我们假设该结点出现在第i+1层的概率为p, 则对于任意一个结点, 它只有1层的概率为（1-p），有两层的概率为p(1-p)，因此跳跃表的层数概率期望：</p><p><img src="https://www.shouxicto.com/zb_users/upload/2021/10/20211007091744163356946420519.webp" alt="跳跃表随机层数概率期望"></p><p>Redis中设定：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">p = 1/4<br>MaxLevel = 64<br></code></pre></td></tr></table></figure><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="1-关键结构"><a href="#1-关键结构" class="headerlink" title="1.关键结构"></a>1.关键结构</h2><p>跳表结点Node，其中key用于存储改结点的值，level是个指针数组，表示改结点每层指向的下一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> max_level;<br>    std::vector&lt;Node*&gt; level;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m);<br>&#125;;<br><span class="hljs-comment">// 构造函数，初始化每个节点的层数指针指向nullptr</span><br>Node::<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m) <br>    : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">max_level</span>(m)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        level.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SkipList 数据结构，这里简单实现了下查找和插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">SkipList</span>(); <br>        <span class="hljs-type">int</span> cur_max_level;<br>        <span class="hljs-type">int</span> MAX_LEVEL;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRandomLevel</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        Node* _header;<br>&#125;;<br><span class="hljs-comment">// 构造函数</span><br>SkipList::<span class="hljs-built_in">SkipList</span>() &#123;<br>    <span class="hljs-keyword">this</span>-&gt;cur_max_level = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>-&gt; MAX_LEVEL = <span class="hljs-number">10</span> ;<br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;MAX_LEVEL);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><p>在单链表中，查找某个值需要从到尾遍历链表，在跳表中类似，只不过可以从结点最少的顶层开始查起，如果找到第一个比key要大的值则往下层找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br>    Node* cur = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">//从顶层向下遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">//在当前层中比较，直到查找元素小于key</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;level[i] &amp;&amp; cur-&gt;level[i]-&gt;key &lt; key)<br>            cur = cur-&gt;level[i];<br>    &#125;<br>    <span class="hljs-comment">// 跳出循环说明已经找到相邻的节点了，拿cur指针level 0结点的值即可</span><br>    cur = cur-&gt;level[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(cur &amp;&amp; cur-&gt;key == key)&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Success find key:&quot;</span>&lt;&lt; key &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout&lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; not in cur skip list.&quot;</span>&lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h2><p>插入主要分为如下三步：</p><p> 1.查找到需要插入的位置，即需要查找插入key值前面的一个结点。在单链表中该步骤就是一个从header开始的遍历操作，在跳表中也一样，只不过要逐层查找一个插入的位置；</p><p>2.申请新的结点。找到合适的位置之后，即可为新结点申请随机层数，如果新的层数比原来的最大层数还要打，那么需要调整下update数组，让空余的层数都指向hader结点。</p><p> 3.调整指针。前面遍历找到了每一层可以插入的前结点，只需逐层插入新结点即可。</p><p>举个例子： 假设当前我们要插入元素“40”，且随机层数为4，</p><p>步骤一：找到表中比40小的最大的数，确定插入位置</p><p><img src="https://www.bloghome.com.cn/content/images/2021/04/20140909174314145.jpeg" alt="查找插入位置"></p><p>步骤二：插入高度为4的列，并维护跳跃表的结构</p><p><img src="https://www.bloghome.com.cn/content/images/2021/04/20140909174119578.jpeg" alt="更新update指针"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br><br>    Node* current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// update 是一个指针数组，数组内存放指针，指向 level指向的节点，其索引代表层</span><br>    Node* update[<span class="hljs-keyword">this</span>-&gt;MAX_LEVEL];<br><br>    <span class="hljs-comment">// 从最高层开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 只要当前节点非空，且 key 小于目标, 就会向后遍历</span><br>        <span class="hljs-keyword">while</span>(current-&gt;level[i] &amp;&amp; current-&gt;level[i]-&gt;key &lt; key) &#123;<br>            current = current-&gt;level[i];  <span class="hljs-comment">// 节点向后移动</span><br>        &#125;<br>        update[i] = current;<br>    &#125;<br>    <span class="hljs-comment">// 遍历到 level 0 说明到达最底层了，forward[0]指向的就是跳表下一个邻近节点</span><br>    current = current-&gt;level[<span class="hljs-number">0</span>];  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != current &amp;&amp; current-&gt;key == key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;key != key ) &#123;<br>        <span class="hljs-comment">// 随机生成层的高度，也即 forward[] 大小</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetRandomLevel</span>();<br>        <span class="hljs-comment">// 如果新添加的节点层高大于当前跳表层高，则需要更新 update 数组</span><br>        <span class="hljs-keyword">if</span> (random_level &gt;= <span class="hljs-keyword">this</span>-&gt;cur_max_level) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level; i &lt; random_level; i++) &#123;<br>                update[i] = <span class="hljs-keyword">this</span>-&gt;_header;<br>            &#125;<br>            <span class="hljs-keyword">this</span>-&gt;cur_max_level = random_level; <span class="hljs-comment">// 最后更新跳表层高</span><br>        &#125;<br>        <span class="hljs-comment">// 创建节点，并进行逐层插入操作</span><br>        Node* inserted_node =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, random_level);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; random_level; i++) &#123;<br>            inserted_node-&gt;level[i] = update[i]-&gt;level[i];<br>            update[i]-&gt;level[i] = inserted_node;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successfully inserted key: &quot;</span> &lt;&lt; inserted_node-&gt;key  &lt;&lt; <span class="hljs-string">&quot;random_level:&quot;</span> &lt;&lt; inserted_node-&gt;max_level &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h1><p>1.上述代码中通过随机的方式生成每个结点出现的层数，但这样有可能导致层数出现的不均衡，使得某些key查找的效率高，某些查找效率低。</p><p>为解决这一问题可以在GetRandomLevel()的时候采用轮询的方式，这样结点出现的层数会均匀分布。</p><h1 id="附完整代码"><a href="#附完整代码" class="headerlink" title="附完整代码"></a>附完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> max_level;<br>    std::vector&lt;Node*&gt; level;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m);<br>&#125;;<br><br>Node::<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m) <br>    : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">max_level</span>(m)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        level.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">SkipList</span>(); <br>        <span class="hljs-type">int</span> cur_max_level;<br>        <span class="hljs-type">int</span> MAX_LEVEL = <span class="hljs-number">10</span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRandomLevel</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        Node* _header;<br><br>&#125;;<br><br>SkipList::<span class="hljs-built_in">SkipList</span>() &#123;<br>    <span class="hljs-keyword">this</span>-&gt;cur_max_level = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;MAX_LEVEL);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::GetRandomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> level = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-keyword">this</span>-&gt;MAX_LEVEL);<br>    level = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, level);<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br>    Node* cur = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">//从顶层向下遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">//在当前层中比较，直到查找元素小于key</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;level[i] &amp;&amp; cur-&gt;level[i]-&gt;key &lt; key)<br>            cur = cur-&gt;level[i];<br>    &#125;<br>    <span class="hljs-comment">// 跳出循环说明已经找到相邻的节点了，拿cur指针level 0结点的值即可</span><br>    cur = cur-&gt;level[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(cur &amp;&amp; cur-&gt;key == key)&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Success find key:&quot;</span>&lt;&lt; key &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout&lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; not in cur skip list.&quot;</span>&lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkipList::display_list</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n******** Skip List ********&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <br>    <span class="hljs-comment">// 逐层打印</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">this</span>-&gt;cur_max_level; i++) &#123;<br>        Node *node = <span class="hljs-keyword">this</span>-&gt;_header-&gt;level[i]; <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Level &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>            std::cout &lt;&lt; node-&gt;key&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt; node-&gt;max_level &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>            node = node-&gt;level[i];<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SkipList::insert_element</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <br><br>    Node* current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// update 是一个指针数组，数组内存放指针，指向 level指向的节点，其索引代表层</span><br>    Node* update[<span class="hljs-keyword">this</span>-&gt;MAX_LEVEL];<br><br>    <span class="hljs-comment">// 从最高层开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 只要当前节点非空，且 key 小于目标, 就会向后遍历</span><br>        <span class="hljs-keyword">while</span>(current-&gt;level[i] &amp;&amp; current-&gt;level[i]-&gt;key &lt; key) &#123;<br>            current = current-&gt;level[i];  <span class="hljs-comment">// 节点向后移动</span><br>        &#125;<br>        update[i] = current;<br>    &#125;<br>    <span class="hljs-comment">// 遍历到 level 0 说明到达最底层了，level[0]指向的就是跳表下一个邻近节点</span><br>    current = current-&gt;level[<span class="hljs-number">0</span>];  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != current &amp;&amp; current-&gt;key == key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;key != key ) &#123;<br>        <span class="hljs-comment">// 随机生成层的高度，也即 forward[] 大小</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetRandomLevel</span>();<br>        <span class="hljs-comment">// 如果新添加的节点层高大于当前跳表层高，则需要更新 update 数组</span><br>        <span class="hljs-keyword">if</span> (random_level &gt;= <span class="hljs-keyword">this</span>-&gt;cur_max_level) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;cur_max_level; i &lt; random_level; i++) &#123;<br>                update[i] = <span class="hljs-keyword">this</span>-&gt;_header;<br>            &#125;<br>            <span class="hljs-keyword">this</span>-&gt;cur_max_level = random_level; <span class="hljs-comment">// 最后更新跳表层高</span><br>        &#125;<br>        <span class="hljs-comment">// 创建节点，并进行插入操作</span><br>        Node* inserted_node =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, random_level);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; random_level; i++) &#123;<br>            inserted_node-&gt;level[i] = update[i]-&gt;level[i];<br>            update[i]-&gt;level[i] = inserted_node;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successfully inserted key: &quot;</span> &lt;&lt; inserted_node-&gt;key  &lt;&lt; <span class="hljs-string">&quot;random_level:&quot;</span> &lt;&lt; inserted_node-&gt;max_level &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;begin: &quot;</span> &lt;&lt;std::endl;<br>    SkipList skip_list;<br>    skip_list.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">1</span>);<br>    skip_list.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">2</span>);<br>    skip_list.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">3</span>);<br>    skip_list.<span class="hljs-built_in">display_list</span>();<br>    skip_list.<span class="hljs-built_in">search</span>(<span class="hljs-number">2</span>);<br>    skip_list.<span class="hljs-built_in">search</span>(<span class="hljs-number">4</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bloghome.com.cn/post/shen-du-li-jie-tiao-yue-lian-biao-yi-chong-ji-yu-gai-lu-xuan-ze-de-ping-heng-shu.html">bloghome博客之家-分享知识-放飞梦想</a></p>]]></content>
    
    
    <categories>
      
      <category>skiplist</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络探测指令</title>
    <link href="/MyBlog/2022/06/08/Linux%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E6%8C%87%E4%BB%A4/"/>
    <url>/MyBlog/2022/06/08/Linux%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>服务端日志维护中，经常需要排查网络连通性及性能，ping、telnet命令有时候不能满足需求，本文收集整理了一些拥有的网络探测命令</p><h2 id="nc-端口探测"><a href="#nc-端口探测" class="headerlink" title="nc 端口探测"></a>nc 端口探测</h2><p>nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具。我们知道telnet host port 只能用于测试tcp连通性，nc的功能包括：</p><p>（1）实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口</p><p>（2）端口的扫描，nc可以作为client发起TCP或UDP连接</p><p>（3）机器之间传输文件</p><p>（4）机器之间网络测速</p><p>1.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">-g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。<br>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。<br>-h 在线帮助。<br>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。<br>-l 使用监听模式，管控传入的资料。<br>-n 直接使用IP地址，而不通过域名服务器。<br>-o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。<br>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。<br>-r 乱数指定本地与远端主机的通信端口。<br>-s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。<br>-u 使用UDP传输协议。<br>-v 显示指令执行过程。<br>-w&lt;超时秒数&gt; 设置等待连线的时间。<br>-z 使用0输入/输出模式，只在扫描通信端口时使用。<br></code></pre></td></tr></table></figure><p>2.简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -v -z -w2 192.168.0.3 1-100 <br>nc -vzw 2 192.168.0.3 1-100 <br></code></pre></td></tr></table></figure><p>该样例扫描192.168.0.3 的端口 范围是 1-100，-v用于显示执行过程，-z不会产生额外的数据包，-w后面跟2表示最大等待时间2秒</p><p>3.拷贝文件</p><p>从server1拷贝文件到server2上。需要先在server2上，用nc激活监听，如下面的命令在server2上监听1234号端口，并把收到的数据写入1234.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">server2：<br>[root@server2 ~]# nc -l 1234 &gt; 1234.txt<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">server1：<br>[root@server1 ~]# cat abc.txt <br>abc.txtabc.txtabc.txtabc.txtabc.txtabc.txtabc.txtabc.txtabc.txt<br>[root@server1 ~]# nc -w 1 192.168.200.27 1234 &lt; abc.txt<br></code></pre></td></tr></table></figure><p>server1调用nc将abc.txt写入192.168.200.27 1234号端口</p><h2 id="traceroute-路径探测"><a href="#traceroute-路径探测" class="headerlink" title="traceroute 路径探测"></a>traceroute 路径探测</h2><p>traceroute命令用于显示数据包到主机间的路径。</p><p>1.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install traceroute<br></code></pre></td></tr></table></figure><p>2.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">-d：使用Socket层级的排错功能；<br>-f&lt;存活数值&gt;：设置第一个检测数据包的存活数值TTL的大小；<br>-F：设置勿离断位；<br>-g&lt;网关&gt;：设置来源路由网关，最多可设置8个；<br>-i&lt;网络界面&gt;：使用指定的网络界面送出数据包；<br>-I：使用ICMP回应取代UDP资料信息；<br>-m&lt;存活数值&gt;：设置检测数据包的最大存活数值TTL的大小；<br>-n：直接使用IP地址而非主机名称；<br>-p&lt;通信端口&gt;：设置UDP传输协议的通信端口；<br>-r：忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-s&lt;来源地址&gt;：设置本地主机送出数据包的IP地址；<br>-t&lt;服务类型&gt;：设置检测数据包的TOS数值；<br>-v：详细显示指令的执行过程；<br>-w&lt;超时秒数&gt;：设置等待远端主机回报的时间；<br>-x：开启或关闭数据包的正确性检验。<br></code></pre></td></tr></table></figure><p>2.简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">traceroute -m 10 www.baidu.com # 跳数设置<br>traceroute -n www.baidu.com    # 显示IP地址，不查主机名<br>traceroute -p 6888 www.baidu.com  # 探测包使用的基本UDP端口设置6888<br>traceroute -q 4 www.baidu.com  # 把探测包的个数设置为值4<br>traceroute -r www.baidu.com    # 绕过正常的路由表，直接发送到网络相连的主机<br>traceroute -w 3 www.baidu.com  # 把对外发探测包的等待响应时间设置为3秒<br></code></pre></td></tr></table></figure><h2 id="mtr-路由探测"><a href="#mtr-路由探测" class="headerlink" title="mtr 路由探测"></a>mtr 路由探测</h2><p>MTR（My traceroute） 是一款强大的网络诊断工具，它集成了 <a href="https://wker.com/besttrace/">traceroute</a> 和 ping 的功能，并且会收集更多的信息，比如连接状态、可用性等等，在排查网络问题中，非常有用。</p><p>1.mrt安装</p><p>在 Linux下可以直接使用 yum 工具（以 CentOS 为例）进行安装：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">yum</span> <span class="hljs-string">provides</span> <span class="hljs-string">mtr</span>      <span class="hljs-comment">#查看mtr命令是由哪个安装包提供</span><br><span class="hljs-string">yum</span> <span class="hljs-string">install</span> <span class="hljs-string">mtr</span> <span class="hljs-string">-y</span>     <span class="hljs-comment">#安装mtr</span><br></code></pre></td></tr></table></figure><p>2.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">-F, --filename FILE        read hostname(s) from a file<br>-4                         use IPv4 only<br>-6                         use IPv6 only<br>-u, --udp                  use UDP instead of ICMP echo<br>-T, --tcp                  use TCP instead of ICMP echo<br>-a, --address ADDRESS      bind the outgoing socket to ADDRESS<br>-f, --first-ttl NUMBER     set what TTL to start<br>-m, --max-ttl NUMBER       maximum number of hops<br>-U, --max-unknown NUMBER   maximum unknown host<br>-P, --port PORT            target port number for TCP, SCTP, or UDP<br>-L, --localport LOCALPORT  source port number for UDP<br>-s, --psize PACKETSIZE     set the packet size used for probing<br>-B, --bitpattern NUMBER    set bit pattern to use in payload<br>-i, --interval SECONDS     ICMP echo request interval<br>-G, --gracetime SECONDS    number of seconds to wait for responses<br>-Q, --tos NUMBER           type of service field in IP header<br>-e, --mpls                 display information from ICMP extensions<br>-Z, --timeout SECONDS      seconds to keep probe sockets open<br>-r, --report               output using report mode<br>-w, --report-wide          output wide report<br>-c, --report-cycles COUNT  set the number of pings sent<br>-j, --json                 output json<br>-x, --xml                  output xml<br>-C, --csv                  output comma separated values<br>-l, --raw                  output raw format<br>-p, --split                split output<br>-t, --curses               use curses terminal interface<br>    --displaymode MODE     select initial display mode<br>-n, --no-dns               do not resove host names<br>-b, --show-ips             show IP numbers and host names<br>-o, --order FIELDS         select output fields<br>-y, --ipinfo NUMBER        select IP information in output<br>-z, --aslookup             display AS number<br>-h, --help                 display this help and exit<br>-v, --version              output version information and exit<br></code></pre></td></tr></table></figure><p>3.简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用-r参数显示报告,默认是动态显示的：<br>mtr -r www.badu.com<br><br>使用-c参数设置每秒发送数据包数量:<br>mtr -r -c 30 www.baidu.com<br><br>使用-s参数指定ping数据包的大小：<br>mtr -r -c 30 -s 1024 www.baidu.com<br></code></pre></td></tr></table></figure><h2 id="wrk-性能探测"><a href="#wrk-性能探测" class="headerlink" title="wrk 性能探测"></a>wrk 性能探测</h2><p>wrk是一款针对HTTP协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I&#x2F;O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。</p><p>1.linux环境安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install build-essential libssl-dev git -y<br>git clone https://github.com/wg/wrk.git wrk<br>cd wrk<br>make<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将可执行文件移动到 /usr/local/bin 位置</span><br>sudo cp wrk /usr/local/bin<br></code></pre></td></tr></table></figure><p>2.使用简介</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wrk -t12 -c400 -d30s http://www.baidu.com<br></code></pre></td></tr></table></figure><p>这条命令表示，利用 wrk 对 <a href="http://www.baidu.com/">www.baidu.com</a> 发起压力测试，线程数为 12，模拟 400 个并发请求，持续 30 秒。</p><p>3.参数说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            <br>  Options:                                            <br>    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  <br>    -d, --duration    &lt;T&gt;  压测时间           <br>    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   <br>                                                      <br>    -s, --script      &lt;S&gt;  指定Lua脚本路径       <br>    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      <br>        --latency          在压测结束后，打印延迟统计信息   <br>        --timeout     &lt;T&gt;  超时时间     <br>    -v, --version          打印正在使用的wrk的详细版本信息<br>                                                      <br>  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)<br>  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/AePNULaXl8sZlIQTTJz2TA">Linux 网络延迟排查方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kcp学习笔记</title>
    <link href="/MyBlog/2022/05/30/kcp%E7%AE%80%E4%BB%8B/"/>
    <url>/MyBlog/2022/05/30/kcp%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="KCP学习笔记"><a href="#KCP学习笔记" class="headerlink" title="KCP学习笔记"></a>KCP学习笔记</h1><p> 网络游戏中通常采用UDP协议来避免TCP拥塞算法的限制，几种常见的UDP开源方案有：QUIC、ENET、KCP、UDT</p><h1 id="kcp-x2F-quic-x2F-enet-x2F-UDT协议的区别"><a href="#kcp-x2F-quic-x2F-enet-x2F-UDT协议的区别" class="headerlink" title="kcp&#x2F;quic&#x2F;enet&#x2F;UDT协议的区别"></a>kcp&#x2F;quic&#x2F;enet&#x2F;UDT协议的区别</h1><ul><li><strong>quic 是一个完整固化的 http 应用层协议</strong>，目前已经更名 http&#x2F;3，指定使用 udp（虽然本质上并不一定需要 udp）。其主要目的是为了整合TCP协议的可靠性和udp协议的速度和效率，其主要特性包括：避免前序包阻塞、减少数据包、向前纠错、会话重启和并行下载等，然而QUIC对标的是TCP+TLS+SPDY，相比其他方案更重，目前国内用于网络游戏较少</li><li><strong>kcp 只是一套基于无连接的数据报文之上的连接和拥塞控制协议</strong>，对底层【无连接的数据报文】没有具体的限制，可以基于 udp，也可以基于伪造的 tcp&#x2F;icmp 等，也可以基于某些特殊环境的非 internet 网络（比如各种现场通信总线）</li><li><strong>enet</strong>: 有ARQ协议。收发不用自己实现，提供连接管理，心跳机制。支持人数固定。自己实现跨平台。支持可靠无序通道。没有拥塞控制。线程不安全</li><li><strong>UDT</strong>建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的<a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&spm=1001.2101.3001.7020">应用层</a>协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。UDT的主要目的是支持高速<a href="https://so.csdn.net/so/search?q=%E5%B9%BF%E5%9F%9F%E7%BD%91&spm=1001.2101.3001.7020">广域网</a>上的海量数据传输。</li></ul><h1 id="kcp基本原理"><a href="#kcp基本原理" class="headerlink" title="kcp基本原理"></a>kcp基本原理</h1><p>KCP以牺牲网络公平性来追求更低的延时，适合游戏一类对延迟敏感的独占式应用。 KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低为三分之一的传输效果。</p><p>纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP</p><h2 id="1-KCP的优势："><a href="#1-KCP的优势：" class="headerlink" title="1.KCP的优势："></a>1.KCP的优势：</h2><p>1）RTO x 2 vs RTO x 1.5 ： 超时增长更平缓, 更快重发。<br> 2）全部重传 vs 选择性重传 ： TCP丢包时全部重传自丢包开始的所有数据包，KCP只重传真正丢失的数据包。（<br> 3）快速重传：当某个包被跳过的此时超过一定阈值时， 直接重传<br> 4）延迟ACK vs 非延迟ACK：TCP为了充分利用带宽，延迟发送ACK。 RTT(Round Trip Time)时间增大，计算出更大的RTO。KCP的ACK是否延迟发送可以调节。</p><p>5）UNA vs ACK+UNA： ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</p><p>6）非退让流控： KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取流畅传输的效果。</p><h2 id="2-KCP数据包"><a href="#2-KCP数据包" class="headerlink" title="2.KCP数据包"></a>2.KCP数据包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPSEG</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">node</span>;</span> <span class="hljs-comment">//报文前后向指针</span><br> IUINT32 conv, <span class="hljs-comment">//会话编号，通信双方必须一致</span><br> IUINT32 cmd, <span class="hljs-comment">//当前报文的类型：IKCP_CMD_PUSH、IKCP_CMD_ACK、ICKP_CMD_WASK、ICKP_CMD_WINS</span><br> IUINT32 frg, <span class="hljs-comment">//分片编号,倒序</span><br> IUINT32 wnd, <span class="hljs-comment">//当前可用窗口大小</span><br> IUINT32 ts, <span class="hljs-comment">//发送时间戳</span><br> IUINT32 sn, <span class="hljs-comment">//报文编号或者确认报文编号</span><br> IUINT32 una, <span class="hljs-comment">//当前未确认的数据包的编号，此编号前的所有报文已经确认</span><br> IUINT32 len, <span class="hljs-comment">//报文数据长度</span><br> IUINT32 resendts, <span class="hljs-comment">//下一次重发该报文的时间</span><br> IUINT32 rto, <span class="hljs-comment">//重传超时</span><br> IUINT32 fastack, <span class="hljs-comment">//收到ACK时被跳过几次，用于快速重传</span><br> IUINT32 xmit, <span class="hljs-comment">//记录该报文被重传了几次</span><br> <span class="hljs-type">char</span> data[<span class="hljs-number">1</span>], <span class="hljs-comment">//数据部分</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-KCP发送模式："><a href="#3-KCP发送模式：" class="headerlink" title="3.KCP发送模式："></a>3.KCP发送模式：</h2><p>流模式 kcp-&gt;stream!&#x3D;0<br>包模式 kcp-&gt;streaam&#x3D;&#x3D;0</p><h2 id="4-KCP发送包的流程"><a href="#4-KCP发送包的流程" class="headerlink" title="4.KCP发送包的流程"></a>4.KCP发送包的流程</h2><p>1）上层应用可以调用 ikcp_send 来发送数据。ikcpcb 中定义了发送相关的缓冲队列和 buf，分别是 snd_queue 和 snd_buf。应用层调用 ikcp_send 后，数据将会进入到 snd_queue 中，而下层函数 ikcp_flush 将会决定将多少数据从 snd_queue 中移到 snd_buf 中，进行发送。<br> 2）若选择流模式，则需要填充snd_queue中最后一个包的空余部分，否则直接安装数据大小封装成若干个kcp_segments放入snd_queue,流模式的分片号frg&#x3D;0,包模式分片递减<br> 3）update的时候会执行ikcp_flush，根据本次发送可用窗口的大小将snd_queue中的数据放到snd_buf中<br> 4）flush的数据报文的时候进行首次发送、超时重传、快速重传、拥塞控制等流量控制</p><h2 id="5-KCP接收数据包"><a href="#5-KCP接收数据包" class="headerlink" title="5.KCP接收数据包"></a>5.KCP接收数据包</h2><p>1)kcp_input输入UDP收到的数据包，并解析出kcp包头;</p><p>2)根据una删除掉snd_buf里所有una之前的kcp数据包；<br>3)根据wnd字段更新接收端的窗口大小;</p><p>4)根据cmd字段分别处理不同格式的包：ACK、CMD_PUSH、CMD_WASK</p><p>5)对于CMD_PUSH格式的数据包，解包放入rcv_buffer中，同时KCP会把收到的数据包的sn、ts放置到acklist中，update时会读取acklist，从而以IKCP_CMD_ACK的命令返回确认包。</p><h2 id="6-接收处理流程"><a href="#6-接收处理流程" class="headerlink" title="6.接收处理流程"></a>6.接收处理流程</h2><p>1）对于IKCP_CMD_PUSH的数据包：KCP会把收到的数据包的sn、ts放置到acklist中，update时会读取acklist，并以IKCP_CMD_ACK的命令返回确认包。<br> 2）在rcv_buf队列中丢弃掉接收窗口之外的和重复的包，将有效数据包移动到rcv_queue,rcv_buf中的数据可能是间隔的，但是rcv_queue中的数据是连续的</p><p>3)对于IKCP_CMD_ACK数据确认包<br>两个使命：1、RTO更新，2、确认发送包接收方已接收到</p><h1 id="kcp数据发送过程"><a href="#kcp数据发送过程" class="headerlink" title="kcp数据发送过程"></a>kcp数据发送过程</h1><p>用户发送数据的函数为ikcp_send。 ikcp_send(ikcpcb kcp, const char buffer, int len)<br>该函数的功能非常简单，把用户发送的数据根据MSS进行分片。如用户发送1900字节的数据，MTU为1400byte。因此，该函数会把1900byte的用户数据分成两个包，一个数据大小为1400，头frg设置为1，len设置为1400；第二个包，头frg设置为0，len设置为500。切好KCP包之后，放入到名为snd_queue的待发送队列中。</p><p>注：流模式情况下，kcp会把两次发送的数据衔接为一个完整的kcp包。非流模式下，用户数据%MSS的包，也会作为一个包发送出去。</p><p>KCP会不停的进行update更新最新情况，数据的实际发送在update时进行。发送过程如下图所示：</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_2d31d4129d488b1f0311b389f0381aeb.png"></p><p><strong>步骤1：待发送队列移至发送队列</strong><br>KCP会把snd_queue待发送队列中的kcp包，移至snd_buf发送队列。移动的包的数量不会超过snd_una+cwnd-snd_nxt，确保发送的数据不会让接收方的接收队列溢出。该功能类似于TCP协议中的滑动窗口。cwnd&#x3D;min(snd_wnd,rmt_wnd,kcp-&gt;cwnd)的最小值决定，snd_wnd，rmt_wnd比较好理解可发送的数据，可发送的数据最大值，应该是发送方可以发送的数据和接收方可以接收的数据的最小值。kcp-&gt;cwnd是拥塞控制的一个值，跟网络状况相关，网络状况差的时候，KCP认为应该降低发送的数据，后面会有详细的介绍。<br>如上图中，snd_queue待发送队列中有4个KCP包等待发送，这个时候snd_nxt下一个发送的kcp包序列号为11，snd_una下一个确认的KCP包为9（8已经确认，9，10已经发送但是还没得到接收方的确认）。因为cwnd&#x3D;5，发送队列中还有2个发送了但是还未得到确认，所以可以从待发送队列中取前面的3个KCP包放入到发送队列中，序列号分别设置为11,12,13。</p><p><strong>步骤2：发送发送队列的数据</strong><br>发送队列中包含两种类型的数据，已发送但是尚未被接收方确认的数据，没被发送过的数据。没发送过的数据比较好处理，直接发送即可。重点在于已经发送了但是还没被接收方确认的数据，该部分的策略直接决定着协议快速、高效与否。KCP主要使用两种策略来决定是否需要重传KCP数据包，<strong>超时重传、快速重传、选择重传。</strong></p><p><strong>1、超时重传</strong><br>TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，而KCP非快速模式下每次+RTO，急速模式下+0.5RTO（实验证明1.5这个值相对比较好），<strong>提高了传输速度。</strong></p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_56527e74be21a25ff46f616227f2abcd.jpg"></p><p><strong>2、快速重传</strong><br>发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。<u>TCP也有快速重传算法，TCP包被跳过3次之后会进行重传。</u><br>注：可以通过统计错误重传（重传的包实际没丢，仅乱序），优化该设置。</p><p><strong>3、选择重传</strong><br>老的TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。但是，目前大部分的操作系统，linux与android手机均是支持SACK选择重传的。</p><p><strong>步骤3：数据发送</strong><br>通过步骤2判定，kcp包是否需要发送，如果需要发送的kcp包则通过，kcp_setoutput设置的发送接口进行发送，UDP通常为sendto。步骤3，会对较小的kcp包进行合并，一次性发送提高效率</p><h1 id="kcp数据接收过程"><a href="#kcp数据接收过程" class="headerlink" title="kcp数据接收过程"></a>kcp数据接收过程</h1><p>KCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。</p><p><strong>2.3.1 KCP数据包接收</strong></p><p>kcp_input输入UDP收到的数据包。kcp包对前面的24个字节进行解压，包括conv、 frg、 cmd、 wnd、 ts、 sn、 una、 len。根据una，会删除snd_buf中，所有una之前的kcp数据包，因为这些数据包接收者已经确认。根据wnd更新接收端接收窗口大小。根据不同的命令字进行分别处理。数据接收后，更新流程如下所示：</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_3256d4c1f19d4445432fb9ade84eea1d.png"></p><p><strong>1、IKCP_CMD_PUSH数据发送命令</strong><br>a、KCP会把收到的数据包的sn及ts放置在acklist中，两个相邻的节点为一组，分别存储sn和ts。<strong>update时会读取acklist，并以IKCP_CMD_ACK的命令返回确认包</strong>。如下图中，收到了两个kpc包，acklist中会分别存放10,123,11,124。<br>b、kcp数据包放置rcv_buf队列。丢弃接收窗口之外的和重复的包。然后将rcv_buf中的包，移至rcv_queue。原来的rcv_buf中已经有sn&#x3D;10和sn&#x3D;13的包了，sn&#x3D;10的kcp包已经在rcv_buf中了，因此新收到的包会直接丢弃掉，sn&#x3D;11的包放置至rcv_buf中。<br>c、把rcv_buf中前面连续的数据sn&#x3D;11，12，13全部移动至rcv_queue，rcv_nxt也变成14。</p><p><strong>rcv_queue的数据是连续的，rcv_buf可能是间隔的</strong><br>d、kcp_recv函数，用户获取接收到数据（去除kcp头的用户数据）。该函数根据frg，把kcp包数据进行组合返回给用户。</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_44e1f9fd5a655f657ac3a1c913697ad9.png"></p><p><strong>2、IKCP_CMD_ACK数据确认包</strong><br>两个使命：1、RTO更新，2、确认发送包接收方已接收到。</p><p><strong>正常情况：</strong>收到的sn为11,una为12。表示sn为11的已经确认，下一个等待接收的为12。发送队列中，待确认的一个包为11，这个时候snd_una向后移动一位，序列号为11的包从发送队列中删除。</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_4f16b7ccbb3e0285c87dd9ca88a2f605.png"></p><p>[ 数据确认包处理流程 ]</p><p><strong>异常情况：</strong>如下图所示，sn!&#x3D;11的情况均为异常情况。sn&lt;11表示，收到重复确认的包，如本来以为丢失的包重新又收到了，所以产生重复确认的包；sn&gt;17，收到没发送过的序列号，概率极低，可能是conv没变重启程序导致的；112，则启动快速重传</p><p><img src="https://f.wetest.qq.com/gqop/10000/20000/LabImage_b08898c35b63d9e02a8b4a229df8b0e4.png"></p><p><em>确认包发送，接收到的包会全部放在acklist中，以IKCP_CMD_ACK包发送出去</em></p><h1 id="KCP使用接口"><a href="#KCP使用接口" class="headerlink" title="KCP使用接口"></a>KCP使用接口</h1><h2 id="1-创建-KCP对象"><a href="#1-创建-KCP对象" class="headerlink" title="1.创建 KCP对象"></a>1.创建 KCP对象</h2><p>初始化 kcp对象，conv为一个表示会话编号的整数，和tcp的 conv一样，通信双</p><p>方需保证 conv相同，相互的数据包才能够被认可，user是一个给回调函数的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ikcpcb *kcp = ikcp_create(conv, user);<br></code></pre></td></tr></table></figure><h2 id="2-设置传输回调函数（如UDP的send函数）"><a href="#2-设置传输回调函数（如UDP的send函数）" class="headerlink" title="2.设置传输回调函数（如UDP的send函数）"></a>2.设置传输回调函数（如UDP的send函数）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// KCP的下层协议输出函数，KCP需要发送数据时会调用它</span><br><br><span class="hljs-comment">// buf/len 表示缓存和长度</span><br><br><span class="hljs-comment">// user指针为 kcp对象创建时传入的值，用于区别多个 KCP对象</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">udp_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, ikcpcb *kcp, <span class="hljs-type">void</span> *user)</span><br><br>&#123;<br> .... <br>&#125;<br><br><span class="hljs-comment">// 设置回调函数</span><br><br>kcp-&gt;output = udp_output;<br></code></pre></td></tr></table></figure><h2 id="3-循环调用-update"><a href="#3-循环调用-update" class="headerlink" title="3. 循环调用 update"></a>3. 循环调用 update</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 以一定频率调用 ikcp_update来更新 kcp状态，并且传入当前时钟（毫秒单位）</span><br><br><span class="hljs-comment">// 如 10ms调用一次，或用 ikcp_check确定下次调用 update的时间不必每次调用</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-输入一个应用层数据包（如UDP收到的数据包）"><a href="#4-输入一个应用层数据包（如UDP收到的数据包）" class="headerlink" title="4. 输入一个应用层数据包（如UDP收到的数据包）"></a>4. 输入一个应用层数据包（如UDP收到的数据包）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 收到一个下层数据包（比如UDP包）时需要调用：</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_input</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">long</span> size)</span>;<br></code></pre></td></tr></table></figure><h2 id="5-发送数据包"><a href="#5-发送数据包" class="headerlink" title="5.发送数据包"></a>5.发送数据包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// flush 发送缓冲区, 会在 ikcp_update 中调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_flush</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br></code></pre></td></tr></table></figure><h1 id="相关扩展"><a href="#相关扩展" class="headerlink" title="相关扩展"></a>相关扩展</h1><h2 id="Jacobson-x2F-Karn算法"><a href="#Jacobson-x2F-Karn算法" class="headerlink" title="Jacobson&#x2F;Karn算法"></a>Jacobson&#x2F;Karn算法</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">为保持数据传输的高效性，TCP中维持了一个超时重传时间间隔：RTO, 时间间隔太短可能导致大量不必要的重传，太长则导致性能下降；因此TCP和KCP均采用了一个高度动态的算法：Jacobson算法，来不断的调整超时重传的RTO<br>    RTO = RTT + <span class="hljs-number">4</span>D    <br>其中RTT是对往返时间的当前最佳估计值，D是平滑的平均偏差<br>    RTT = aRTT + (<span class="hljs-number">1</span>-<span class="hljs-keyword">a</span>)M<br>其中M是自数据包发送到被确认所花费的时间，<span class="hljs-keyword">a</span>是平滑因子，经典值是 <span class="hljs-number">7</span>/<span class="hljs-number">8</span>,及旧的RTT占比重的<span class="hljs-number">7</span>/<span class="hljs-number">8</span>的权重，新测量的往返时间占<span class="hljs-number">1</span>/<span class="hljs-number">8</span><br>    D = aD + (<span class="hljs-number">1</span>-<span class="hljs-keyword">a</span>)|RTT-M|<br>Jacobson 算法只用于处理正常的情况，但是当发生重传后，如果收到一个确认，这时候就不用这个算法来调整 RTO 值了。因为你无法判断这个确认是针对第一次传输，还是后来的重传。在这种情况下，采用 Karn 算法来调整 RTO 的值 。<br>Karn 算法很简单：<br><span class="hljs-number">1</span>）、 对于发生重传的数据段，在收到确认后，不更新 RTT<br><span class="hljs-number">2</span>）、在重传的时候，RTO 是倍增的，直到达到最大值的限制。如果重传超过一定的次数，TCP 连接会断开<br><span class="hljs-number">3</span>）、在重传并收到确认后，如果下一次的数据段没有发生重传（即一次性收到确认），则又恢复 Jacobson 算法<br></code></pre></td></tr></table></figure><h2 id="曾经遇到的一个面试题"><a href="#曾经遇到的一个面试题" class="headerlink" title="曾经遇到的一个面试题"></a>曾经遇到的一个面试题</h2><p>问题：对于一个采用UDP传输协议的网络，假如第一个包的1号分片和第二个包的1号分片同时到达，而接收队列只能缓存1个包（1024个分片），应该怎样处理？<br> 答：问题描述中，1号分片和1025号分片同时到达，接收队列只能缓存1024个分片，若只有一个缓存队列且无法队列无法扩展，那么只有在队列满的时候丢弃掉1025号，然后前1024号分片从缓存队列移除后重传1025，但是通过KCP的两级队列可以有效解决这一问题：1号和1025号同时缓存在rev_buffer中，等2号、3号等分片到来时，连续分片（1&#x2F;2&#x2F;3）会被移动到rev_queue,从而保证rev_buffer不会超过1024的容量，若先到的不是2号分片，则在2号被跳过3次后认为2号丢失，会立即重传。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://disenone.github.io/2019/12/17/kcp">KCP 源码剖析 - Disenone</a></p><p><a href="https://wetest.qq.com/lab/view/391.html?=content_qcloud">专栏 - 腾讯WeTest，您的质量守护专家</a></p><p><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP 协议的原理和实现 - Luyu Huang’s Tech Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
      <category>kcp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flask框架使用</title>
    <link href="/MyBlog/2022/05/30/flask%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/MyBlog/2022/05/30/flask%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="利用flask快速创建http服务"><a href="#利用flask快速创建http服务" class="headerlink" title="利用flask快速创建http服务"></a>利用flask快速创建http服务</h1><p>Flask 是一个微型的 <a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Python">Python</a> 开发的 Web 框架，基于<a href="https://www.oschina.net/p/werkzeug">Werkzeug</a> WSGI工具箱和<a href="https://www.oschina.net/p/jinja">Jinja2</a> 模板引擎。现在我想用它来做一个web通信服务框架。</p><h2 id="安装flask"><a href="#安装flask" class="headerlink" title="安装flask"></a>安装flask</h2><p> <code>pip install flask</code></p><h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment">#coding=utf-8</span><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">import</span> json<br><br>app = Flask(__name__)<br>app.debug = <span class="hljs-literal">True</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/http/query/&#x27;</span>, methods=[<span class="hljs-string">&#x27;post&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">post_http</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.data:  <span class="hljs-comment"># 检测是否有数据</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;fail&#x27;</span>)<br>    params = request.data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-comment"># 获取到POST过来的数据，因为我这里传过来的数据需要转换一下编码。根据晶具体情况而定</span><br>    prams = json.loads(params)<br>    <span class="hljs-built_in">print</span>(prams)<br>    <span class="hljs-comment"># 把区获取到的数据转为JSON格式。</span><br>    <span class="hljs-keyword">return</span> jsonify(prams)<br>    <span class="hljs-comment"># 返回JSON数据。</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods = [<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;POST&quot;</span>]</span>)   </span><span class="hljs-comment"># GET 和 POST 都可以</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>():<br>    name = request.args.get(<span class="hljs-string">&quot;name&quot;</span>)<br>    age = request.args.get(<span class="hljs-string">&quot;age&quot;</span>)<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;hello&#x27;</span>, name, age<br>    res = <span class="hljs-string">&#x27;hello:%s&#x27;</span>%name<br>    check_result_info = &#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>&#125;<br>    check_result_info.update(&#123;<span class="hljs-string">&#x27;res&#x27;</span>: res&#125;)<br>    <span class="hljs-keyword">return</span> jsonify(check_result_info)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端post.py：<br>新启一个终端运行 sudo python3 post.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-#请求htp/query/接口</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Fri Jun 12 18:55:07 2020</span><br><span class="hljs-string">@author: ansonwan</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> requests, json<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> time<br>data = &#123;<br>    <span class="hljs-string">&quot;datatime&quot;</span>: <span class="hljs-string">&quot;2020-07-02&quot;</span><br>&#125;<br><span class="hljs-comment"># 这里地址要和上面的服务端地址及端口好一致</span><br>url = <span class="hljs-string">&#x27;http://127.0.0.1:5000/http/query/&#x27;</span><br><br><span class="hljs-comment"># r = requests.post(url, data=json.dumps(data))</span><br><span class="hljs-comment"># print(r.json())</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    now_time = datetime.datetime.now().strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<span class="hljs-comment"># 打印当前时间</span><br>    data[<span class="hljs-string">&quot;datatime&quot;</span>] = now_time<br>    r = requests.post(url, data=json.dumps(data)) <span class="hljs-comment"># 发送到服务端</span><br>    time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb实践</title>
    <link href="/MyBlog/2022/05/30/mongodb/"/>
    <url>/MyBlog/2022/05/30/mongodb/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>mongod</strong> 是 MongoDB 系统的主要后台进程。它处理数据请求，管理数据访问，执行后台管理操作。</p><p><strong>mongos</strong> 就是 “MongoDB Shard” 的简写，它是一个针对MongoDB分片配置的路由服务，该服务处理来自应用层的查询请求，确定数据在分片集群中的位置，以完成这些操作。从应用的角度来看，一个<strong>mongos</strong>实例表现得跟任何其他MongoDB实例完全相同</p><p><strong>shard</strong>:分片，是指将数据库拆分，将其分散在不同的机器上的过程，将数据分散到不同机器上不需要功能强大的服务器就可以存储更多的数据和处理更大的负载。其基本思想是将集合切成小块，这些小块分散到若干片里，并通过一个均衡器来对各个分片进行均衡及数据迁移。</p><p><strong>config server</strong> 配置服务器，用于存储所有的数据元信息（路由、分片）的配置。mongos本身没有物理存储分片服务器和数据路由信息，只缓存在内存里，配置服务器则实际存储这些数据，mongos第一次启动或者关掉重启就会从config server中加载配置信息，以及config server信息变化时会通知所有的mongos更新自己的状态。</p><p><strong>replica set</strong>： 副本集，其实就是shard的备份，防止shard挂掉之后数据丢失。复制提供了数据的冗余备份，并在多个服务器上存储数据副本。提供了数据的可用性并可保证数据的安全性。<br><strong>arbiter</strong>:仲裁者，是复制集中的一个mongodb实例，它并不保存数据。</p><p>总结：mongodb中，应用请求mongos来操作数据库进行增删改查，config server中存储数据库元信息，并和mongos同步，数据最终存储在shard上，为防止数据丢失同步在副本集中存储了一份。仲裁在数据存储到分片时觉得存储到哪个节点。</p><h1 id="mongodb数据访问过程"><a href="#mongodb数据访问过程" class="headerlink" title="mongodb数据访问过程"></a>mongodb数据访问过程</h1><p>MongoDB是个主从架构的数据库（开发中通常使用分片+副本集），以BSON文档的形式存数据库，额外加了些自己的东西，并以二进制编码存储。存储形式是双向链表。</p><p>MongoDB中配置有一个主节点(Primary)，多个从节点(Secondary)，并彼此之间维持心跳，当主节点挂掉后，则发生[选举](<a href="https://mongoing.com/archives/295">MongoDB的选举过程 | MongoDB中文社区</a>)，其中一个从节点变成</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/replication.png" alt="MongoDB复制结构图"></p><p>mongos 是 MongoDB 分片集群的访问入口，mongos 收到 Client 访问请求，会根据从 Config Server 获取的路由表将请求转发到后端对应的 Shard 上（通常根据_id做hash）。这里不得不说的一个容易踩坑点：通常采用Updata或者findAndModify对分片数据进行更新操作时，如果没有带分片键（_id）则会操作失败，具体原因可以看：[详解](<a href="https://blog.wolfogre.com/posts/trap-of-update-on-sharding-mongodb/">在分片的 MongoDB Collection 上做更新操作时需要注意的问题 | Wolfogre&#39;s Blog</a>) （通常为了节省资源，开发环境不会对collection配置分片，导致开发环境没问题，线上update就出错，别问我为什么知道，都是血的教训）</p><h1 id="mongos连接池"><a href="#mongos连接池" class="headerlink" title="mongos连接池"></a>mongos连接池</h1><p>mongo 分片架构中，mongos 作为 mongo 分片架构的路由选择器，使用中可能比较困惑的一个问题是 ： 客户端到 mongos 和 mongos 到 mongod 的连接数是什么样的关系？是 1: 1 的关系吗？ mongos 的连接池管理策略又是怎样的？</p><p>mongos和mongod都有各自能承受的组大连接数。通常mongos和mongod的最大连接数默认值是08*ulimit -n 约为65536。 默认情况下 mongos 对客户端连接都是【 每连接每线程 】的模型，每个线程分配 1 M 的内存。mongos 内部有两种类型的连接池：传统的连接池( DBConnectionPool 结构) 和 ASIO 的连接池 ( ConnectionPool 结构)。传统连接池内的连接执行命令不会创建新的线程，是在 mongos 接收的连接创建的线程上执行的，所以不会消耗额外的内存空间。具体可参考：<a href="https://mongoing.com/archives/30014">深度剖析mongos连接池 | MongoDB中文社区</a></p><p>在实际业务中，要注意启服时大量玩家查询操作触发连接超过连接池及线程上限的情况。</p><h1 id="mongodb分片详解"><a href="#mongodb分片详解" class="headerlink" title="mongodb分片详解"></a>mongodb分片详解</h1><p>Mongo分片集群中每个数据库都有自己的 primary shard, 未分片的集合存储在 primary shard 上，已分片的集合根据 shardKey 切割成不同的 chunk 分布到多个分片上。Mongo中最常见的分片方式有两种：范围分片和hash 分片</p><h2 id="1-范围分片（Range-based-sharding）"><a href="#1-范围分片（Range-based-sharding）" class="headerlink" title="1.范围分片（Range based sharding）"></a>1.范围分片（Range based sharding）</h2><p>范围分片以shard key所属范围区间为依据对集合进行划分，根据字段的范围不同将一个集合的数据存储在不同的分片中。其原理如图</p><p><img src="/MyBlog/images/5f3f2bab6158bc7847e47cefxLlriGD101.png"></p><p>范围分片适合满足在一定范围内的查找，例如查找X的值在【100-200】之间的数据，mongo 路由根据Config server中存储的元数据，可以直接定位到指定的shard的Chunk中，但是如果shardkey有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力。</p><h2 id="2-Hash分片（Hash-based-sharding）"><a href="#2-Hash分片（Hash-based-sharding）" class="headerlink" title="2.Hash分片（Hash based sharding）"></a>2.Hash分片（Hash based sharding）</h2><p> Hash分片是根据shard key计算hash值，并根据hash值按照范围分片的策略将文档分布到不同chunk上的过程。其原理如图:</p><p><img src="/MyBlog/images/5f3f2bd02dcade25208581b3t0bFhCRS01.png"></p><p>Hash分片能将文档随机分散到各个chunk上，充分的扩展写能力，弥补了范围分片的不足，但是Hash分片不能高效的服务范围查询，所有的范围查询都要分发到后端所有的Shard才能找出满足条件的文档。</p><h1 id="常用命令行操作"><a href="#常用命令行操作" class="headerlink" title="常用命令行操作"></a>常用命令行操作</h1><p>命令行登录远程mongos</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mongo</span> -host <span class="hljs-number">127.0.0.1</span> -port <span class="hljs-number">333</span> -u username -p password dbname<br></code></pre></td></tr></table></figure><p>查看数据库</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> dbs<br></code></pre></td></tr></table></figure><p>创建、切换数据库</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> <span class="hljs-keyword">db</span><br></code></pre></td></tr></table></figure><p>查看所有的数据表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> collections<br></code></pre></td></tr></table></figure><p>创建表</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">db.createCollectio<span class="hljs-meta">n</span>(<span class="hljs-string">&#x27;表名&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>mongo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker实践</title>
    <link href="/MyBlog/2022/05/27/docker%E5%AE%9E%E8%B7%B5/"/>
    <url>/MyBlog/2022/05/27/docker%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h1><p>docker底层的核心技术包括linux上的命名空间（Namespaces）、控制组（Control groups）、 Union文件系统和容器格式（Container format）</p><h2 id="1-docker镜像"><a href="#1-docker镜像" class="headerlink" title="1.docker镜像"></a>1.docker镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><p><strong>分层存储</strong>：因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构</p><p>分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h2 id="2-docker容器"><a href="#2-docker容器" class="headerlink" title="2.docker容器"></a>2.docker容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h2 id="3-docker仓库"><a href="#3-docker仓库" class="headerlink" title="3.docker仓库"></a>3.docker仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="/docker_practice/repository/registry">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（&#96;</p><h2 id="4-docker-in-docker"><a href="#4-docker-in-docker" class="headerlink" title="4.docker in docker"></a>4.docker in docker</h2><p>docker in docker 顾名思义就是在docker里运行docker，现在很多服务大多部署在云上，容器云是常见的服务端架构，为了业务的快速部署，docker in docker经常被应用到容器云的业务开发。</p><p><img src="https://www.chenshaowen.com/blog/images/2020/11/dind.png"></p><h1 id="Dockerfile实例"><a href="#Dockerfile实例" class="headerlink" title="Dockerfile实例"></a>Dockerfile实例</h1><p>上面提到docker采用<code>Union FS</code>文件系统，通过分层存储文件，其具体可表现在Dockerfile上，我们通过dockerfile自定义镜像时，可以在自己或者别人已经定义好的镜像基础上逐层累加，例如我们编写一个基于debian系统的带python环境的镜像：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">FROM</span> <span class="hljs-string">debian</span><br><span class="hljs-string">COPY</span> . /<span class="hljs-string">home</span><br><span class="hljs-string">CMD</span> [<span class="hljs-string">&quot;bash&quot;</span>] <br><span class="hljs-string">LABEL</span> <span class="hljs-string">maintainer</span>=<span class="hljs-string">&#x27;python_work&#x27;</span><br><span class="hljs-string">RUN</span> \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">m</span> <span class="hljs-string">update</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> <span class="hljs-string">upgrade</span>  -<span class="hljs-string">y</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">wget</span> &amp;&amp; \<br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">curl</span><br><br><br><span class="hljs-string">RUN</span> <span class="hljs-string">groupadd</span> -<span class="hljs-string">r</span> <span class="hljs-string">zhouxiao</span> &amp;&amp; \<br><span class="hljs-string">useradd</span> -<span class="hljs-string">r</span> -<span class="hljs-string">d</span> <span class="hljs-string">&quot;/home/zhouxiao&quot;</span> -<span class="hljs-string">m</span> -<span class="hljs-string">s</span> <span class="hljs-string">&quot;/bin/bash&quot;</span> -<span class="hljs-string">p</span> <span class="hljs-string">&quot;zhouxiao&quot;</span> -<span class="hljs-string">g</span> <span class="hljs-string">zhouxiao</span> <span class="hljs-string">admin</span><br><br><span class="hljs-comment"># Install Python</span><br><span class="hljs-string">RUN</span> \ <br><span class="hljs-string">apt-get</span> -<span class="hljs-string">y</span> <span class="hljs-string">install</span> <span class="hljs-string">python</span> <span class="hljs-string">libpython2</span>.<span class="hljs-string">7</span> <span class="hljs-string">telnet</span> <span class="hljs-string">vim</span> <span class="hljs-string">procps</span> <span class="hljs-string">rsyslog</span> <span class="hljs-string">zip</span>&amp;&amp; \<br><span class="hljs-string">wget</span> <span class="hljs-string">https</span>://<span class="hljs-string">bootstrap</span>.<span class="hljs-string">pypa</span>.<span class="hljs-string">io</span>/<span class="hljs-string">pip</span>/<span class="hljs-string">2</span>.<span class="hljs-string">7</span>/<span class="hljs-built_in">get-pip.py</span> &amp;&amp; \<br><span class="hljs-string">python</span> <span class="hljs-built_in">get-pip.py</span> &amp;&amp; \<br><span class="hljs-string">curl</span> -<span class="hljs-string">sL</span> <span class="hljs-string">https</span>://<span class="hljs-string">deb</span>.<span class="hljs-string">nodesource</span>.<span class="hljs-string">com</span>/<span class="hljs-string">setup_12</span>.<span class="hljs-string">x</span> | <span class="hljs-string">bash</span> -  &amp;&amp; \<br><span class="hljs-string">apt-get</span> <span class="hljs-string">clean</span><br></code></pre></td></tr></table></figure><p>！！ 这里<code>From</code>定义了基础镜像为debian，此外<code>COPY</code>、<code>RUN</code>等每一条命令均代表一层镜像，因此尽量将指令结合成一条可节省使用到的层数。</p><p>有了Dockerfile后我们可以生成自定义镜像：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">docker <span class="hljs-keyword">build </span>-t python_test:<span class="hljs-built_in">v1</span> -f Dockerfile .<br></code></pre></td></tr></table></figure><p>这里我们生成了python_test这个镜像，接下来可以通过这个镜像创建容器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name mypython -d python_test:v1 /bin/bash</span><br></code></pre></td></tr></table></figure><h1 id="docker-容器内文件映射"><a href="#docker-容器内文件映射" class="headerlink" title="docker 容器内文件映射"></a>docker 容器内文件映射</h1><p>有时候我们不想在镜像中copy本地文件进去，因为这样会导致镜像占用文件贼大。我们可以使用<code>docker run -v</code>指令在创建Docker容器时与本地路径进行映射共享文件，例如我需要将本地的的<code>/root/code</code>路径映射到容器内的<code>/data/code</code>路径，使用如下指令，冒号前为宿主机路径，冒号后为容器路径，其中xxx为镜像完整路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -v /root/code:/data/code xxx /bin/bash<br></code></pre></td></tr></table></figure><h1 id="docker实践"><a href="#docker实践" class="headerlink" title="docker实践"></a>docker实践</h1><p>1.由于docker采用c&#x2F;s架构，所以要先启动docker服务；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">service</span> docker status <span class="hljs-comment">#查看docker服务状态</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"> service docker <span class="hljs-literal">start</span> <span class="hljs-comment">#启动docker服务</span><br></code></pre></td></tr></table></figure><p>2.由于我本地安装的是windows版本，因此可直接启动cmd输入docker连接docker服务</p><p>3.下载镜像然后可以直接通过镜像创建容器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull nginx</span><br></code></pre></td></tr></table></figure><p>3.可以根据镜像源自定义Dockerfile文件，然后docker build创建自己的镜像</p><p>4.启动镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name webserver -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx<br></code></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>5.使用 <code>docker exec</code> 命令进入容器，修改其内容。（注意该容器必须是启动状态）</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> webserver bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/MyBlog/2021/05/20/hello-world/"/>
    <url>/MyBlog/2021/05/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Like every programmer，I used to use hello world at the beginning, so I kept it.</p><p>This is a personal blog built by hexo + github pages</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
